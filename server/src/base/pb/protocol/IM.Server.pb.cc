// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Server.proto

#include "IM.Server.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)

namespace protobuf_IM_2eBaseDefine_2eproto {
extern PROTOBUF_INTERNAL_EXPORT_protobuf_IM_2eBaseDefine_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_IpAddr;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_IM_2eBaseDefine_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_PushResult;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_IM_2eBaseDefine_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_ServerUserStat;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_IM_2eBaseDefine_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_ShieldStatus;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_IM_2eBaseDefine_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_UserInfo;
extern PROTOBUF_INTERNAL_EXPORT_protobuf_IM_2eBaseDefine_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_UserTokenInfo;
}  // namespace protobuf_IM_2eBaseDefine_2eproto
namespace IM {
namespace Server {
class IMStopReceivePacketDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IMStopReceivePacket>
      _instance;
} _IMStopReceivePacket_default_instance_;
class IMValidateReqDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IMValidateReq>
      _instance;
} _IMValidateReq_default_instance_;
class IMValidateRspDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IMValidateRsp>
      _instance;
} _IMValidateRsp_default_instance_;
class IMGetDeviceTokenReqDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IMGetDeviceTokenReq>
      _instance;
} _IMGetDeviceTokenReq_default_instance_;
class IMGetDeviceTokenRspDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IMGetDeviceTokenRsp>
      _instance;
} _IMGetDeviceTokenRsp_default_instance_;
class IMRoleSetDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IMRoleSet>
      _instance;
} _IMRoleSet_default_instance_;
class IMOnlineUserInfoDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IMOnlineUserInfo>
      _instance;
} _IMOnlineUserInfo_default_instance_;
class IMMsgServInfoDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IMMsgServInfo>
      _instance;
} _IMMsgServInfo_default_instance_;
class IMUserStatusUpdateDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IMUserStatusUpdate>
      _instance;
} _IMUserStatusUpdate_default_instance_;
class IMUserCntUpdateDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IMUserCntUpdate>
      _instance;
} _IMUserCntUpdate_default_instance_;
class IMServerKickUserDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IMServerKickUser>
      _instance;
} _IMServerKickUser_default_instance_;
class IMServerPCLoginStatusNotifyDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IMServerPCLoginStatusNotify>
      _instance;
} _IMServerPCLoginStatusNotify_default_instance_;
class IMPushToUserReqDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IMPushToUserReq>
      _instance;
} _IMPushToUserReq_default_instance_;
class IMPushToUserRspDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IMPushToUserRsp>
      _instance;
} _IMPushToUserRsp_default_instance_;
class IMGroupGetShieldReqDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IMGroupGetShieldReq>
      _instance;
} _IMGroupGetShieldReq_default_instance_;
class IMGroupGetShieldRspDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IMGroupGetShieldRsp>
      _instance;
} _IMGroupGetShieldRsp_default_instance_;
class IMFileTransferReqDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IMFileTransferReq>
      _instance;
} _IMFileTransferReq_default_instance_;
class IMFileTransferRspDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IMFileTransferRsp>
      _instance;
} _IMFileTransferRsp_default_instance_;
class IMFileServerIPReqDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IMFileServerIPReq>
      _instance;
} _IMFileServerIPReq_default_instance_;
class IMFileServerIPRspDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<IMFileServerIPRsp>
      _instance;
} _IMFileServerIPRsp_default_instance_;
}  // namespace Server
}  // namespace IM
namespace protobuf_IM_2eServer_2eproto {
static void InitDefaultsIMStopReceivePacket() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::IM::Server::_IMStopReceivePacket_default_instance_;
    new (ptr) ::IM::Server::IMStopReceivePacket();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::IM::Server::IMStopReceivePacket::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_IMStopReceivePacket =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsIMStopReceivePacket}, {}};

static void InitDefaultsIMValidateReq() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::IM::Server::_IMValidateReq_default_instance_;
    new (ptr) ::IM::Server::IMValidateReq();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::IM::Server::IMValidateReq::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_IMValidateReq =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsIMValidateReq}, {}};

static void InitDefaultsIMValidateRsp() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::IM::Server::_IMValidateRsp_default_instance_;
    new (ptr) ::IM::Server::IMValidateRsp();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::IM::Server::IMValidateRsp::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_IMValidateRsp =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsIMValidateRsp}, {
      &protobuf_IM_2eBaseDefine_2eproto::scc_info_UserInfo.base,}};

static void InitDefaultsIMGetDeviceTokenReq() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::IM::Server::_IMGetDeviceTokenReq_default_instance_;
    new (ptr) ::IM::Server::IMGetDeviceTokenReq();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::IM::Server::IMGetDeviceTokenReq::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_IMGetDeviceTokenReq =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsIMGetDeviceTokenReq}, {}};

static void InitDefaultsIMGetDeviceTokenRsp() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::IM::Server::_IMGetDeviceTokenRsp_default_instance_;
    new (ptr) ::IM::Server::IMGetDeviceTokenRsp();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::IM::Server::IMGetDeviceTokenRsp::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_IMGetDeviceTokenRsp =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsIMGetDeviceTokenRsp}, {
      &protobuf_IM_2eBaseDefine_2eproto::scc_info_UserTokenInfo.base,}};

static void InitDefaultsIMRoleSet() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::IM::Server::_IMRoleSet_default_instance_;
    new (ptr) ::IM::Server::IMRoleSet();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::IM::Server::IMRoleSet::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_IMRoleSet =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsIMRoleSet}, {}};

static void InitDefaultsIMOnlineUserInfo() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::IM::Server::_IMOnlineUserInfo_default_instance_;
    new (ptr) ::IM::Server::IMOnlineUserInfo();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::IM::Server::IMOnlineUserInfo::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_IMOnlineUserInfo =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsIMOnlineUserInfo}, {
      &protobuf_IM_2eBaseDefine_2eproto::scc_info_ServerUserStat.base,}};

static void InitDefaultsIMMsgServInfo() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::IM::Server::_IMMsgServInfo_default_instance_;
    new (ptr) ::IM::Server::IMMsgServInfo();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::IM::Server::IMMsgServInfo::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_IMMsgServInfo =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsIMMsgServInfo}, {}};

static void InitDefaultsIMUserStatusUpdate() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::IM::Server::_IMUserStatusUpdate_default_instance_;
    new (ptr) ::IM::Server::IMUserStatusUpdate();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::IM::Server::IMUserStatusUpdate::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_IMUserStatusUpdate =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsIMUserStatusUpdate}, {}};

static void InitDefaultsIMUserCntUpdate() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::IM::Server::_IMUserCntUpdate_default_instance_;
    new (ptr) ::IM::Server::IMUserCntUpdate();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::IM::Server::IMUserCntUpdate::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_IMUserCntUpdate =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsIMUserCntUpdate}, {}};

static void InitDefaultsIMServerKickUser() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::IM::Server::_IMServerKickUser_default_instance_;
    new (ptr) ::IM::Server::IMServerKickUser();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::IM::Server::IMServerKickUser::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_IMServerKickUser =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsIMServerKickUser}, {}};

static void InitDefaultsIMServerPCLoginStatusNotify() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::IM::Server::_IMServerPCLoginStatusNotify_default_instance_;
    new (ptr) ::IM::Server::IMServerPCLoginStatusNotify();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::IM::Server::IMServerPCLoginStatusNotify::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_IMServerPCLoginStatusNotify =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsIMServerPCLoginStatusNotify}, {}};

static void InitDefaultsIMPushToUserReq() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::IM::Server::_IMPushToUserReq_default_instance_;
    new (ptr) ::IM::Server::IMPushToUserReq();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::IM::Server::IMPushToUserReq::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_IMPushToUserReq =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsIMPushToUserReq}, {
      &protobuf_IM_2eBaseDefine_2eproto::scc_info_UserTokenInfo.base,}};

static void InitDefaultsIMPushToUserRsp() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::IM::Server::_IMPushToUserRsp_default_instance_;
    new (ptr) ::IM::Server::IMPushToUserRsp();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::IM::Server::IMPushToUserRsp::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_IMPushToUserRsp =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsIMPushToUserRsp}, {
      &protobuf_IM_2eBaseDefine_2eproto::scc_info_PushResult.base,}};

static void InitDefaultsIMGroupGetShieldReq() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::IM::Server::_IMGroupGetShieldReq_default_instance_;
    new (ptr) ::IM::Server::IMGroupGetShieldReq();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::IM::Server::IMGroupGetShieldReq::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_IMGroupGetShieldReq =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsIMGroupGetShieldReq}, {}};

static void InitDefaultsIMGroupGetShieldRsp() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::IM::Server::_IMGroupGetShieldRsp_default_instance_;
    new (ptr) ::IM::Server::IMGroupGetShieldRsp();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::IM::Server::IMGroupGetShieldRsp::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_IMGroupGetShieldRsp =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsIMGroupGetShieldRsp}, {
      &protobuf_IM_2eBaseDefine_2eproto::scc_info_ShieldStatus.base,}};

static void InitDefaultsIMFileTransferReq() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::IM::Server::_IMFileTransferReq_default_instance_;
    new (ptr) ::IM::Server::IMFileTransferReq();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::IM::Server::IMFileTransferReq::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_IMFileTransferReq =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsIMFileTransferReq}, {}};

static void InitDefaultsIMFileTransferRsp() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::IM::Server::_IMFileTransferRsp_default_instance_;
    new (ptr) ::IM::Server::IMFileTransferRsp();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::IM::Server::IMFileTransferRsp::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_IMFileTransferRsp =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsIMFileTransferRsp}, {}};

static void InitDefaultsIMFileServerIPReq() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::IM::Server::_IMFileServerIPReq_default_instance_;
    new (ptr) ::IM::Server::IMFileServerIPReq();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::IM::Server::IMFileServerIPReq::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_IMFileServerIPReq =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsIMFileServerIPReq}, {}};

static void InitDefaultsIMFileServerIPRsp() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::IM::Server::_IMFileServerIPRsp_default_instance_;
    new (ptr) ::IM::Server::IMFileServerIPRsp();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::IM::Server::IMFileServerIPRsp::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_IMFileServerIPRsp =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsIMFileServerIPRsp}, {
      &protobuf_IM_2eBaseDefine_2eproto::scc_info_IpAddr.base,}};

void InitDefaults() {
  ::google::protobuf::internal::InitSCC(&scc_info_IMStopReceivePacket.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IMValidateReq.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IMValidateRsp.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IMGetDeviceTokenReq.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IMGetDeviceTokenRsp.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IMRoleSet.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IMOnlineUserInfo.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IMMsgServInfo.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IMUserStatusUpdate.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IMUserCntUpdate.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IMServerKickUser.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IMServerPCLoginStatusNotify.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IMPushToUserReq.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IMPushToUserRsp.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IMGroupGetShieldReq.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IMGroupGetShieldRsp.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IMFileTransferReq.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IMFileTransferRsp.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IMFileServerIPReq.base);
  ::google::protobuf::internal::InitSCC(&scc_info_IMFileServerIPRsp.base);
}

}  // namespace protobuf_IM_2eServer_2eproto
namespace IM {
namespace Server {

// ===================================================================

void IMStopReceivePacket::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMStopReceivePacket::kResultFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMStopReceivePacket::IMStopReceivePacket()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_IM_2eServer_2eproto::scc_info_IMStopReceivePacket.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMStopReceivePacket)
}
IMStopReceivePacket::IMStopReceivePacket(const IMStopReceivePacket& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  result_ = from.result_;
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMStopReceivePacket)
}

void IMStopReceivePacket::SharedCtor() {
  result_ = 0u;
}

IMStopReceivePacket::~IMStopReceivePacket() {
  // @@protoc_insertion_point(destructor:IM.Server.IMStopReceivePacket)
  SharedDtor();
}

void IMStopReceivePacket::SharedDtor() {
}

void IMStopReceivePacket::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IMStopReceivePacket& IMStopReceivePacket::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_IM_2eServer_2eproto::scc_info_IMStopReceivePacket.base);
  return *internal_default_instance();
}


void IMStopReceivePacket::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMStopReceivePacket)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  result_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool IMStopReceivePacket::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMStopReceivePacket)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 result = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_result();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMStopReceivePacket)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMStopReceivePacket)
  return false;
#undef DO_
}

void IMStopReceivePacket::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMStopReceivePacket)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 result = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->result(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMStopReceivePacket)
}

size_t IMStopReceivePacket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMStopReceivePacket)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required uint32 result = 1;
  if (has_result()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->result());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMStopReceivePacket::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMStopReceivePacket*>(&from));
}

void IMStopReceivePacket::MergeFrom(const IMStopReceivePacket& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMStopReceivePacket)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_result()) {
    set_result(from.result());
  }
}

void IMStopReceivePacket::CopyFrom(const IMStopReceivePacket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMStopReceivePacket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMStopReceivePacket::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void IMStopReceivePacket::Swap(IMStopReceivePacket* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMStopReceivePacket::InternalSwap(IMStopReceivePacket* other) {
  using std::swap;
  swap(result_, other->result_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string IMStopReceivePacket::GetTypeName() const {
  return "IM.Server.IMStopReceivePacket";
}


// ===================================================================

void IMValidateReq::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMValidateReq::kUserNameFieldNumber;
const int IMValidateReq::kPasswordFieldNumber;
const int IMValidateReq::kAttachDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMValidateReq::IMValidateReq()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_IM_2eServer_2eproto::scc_info_IMValidateReq.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMValidateReq)
}
IMValidateReq::IMValidateReq(const IMValidateReq& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  user_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_user_name()) {
    user_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.user_name_);
  }
  password_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_password()) {
    password_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.password_);
  }
  attach_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_attach_data()) {
    attach_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.attach_data_);
  }
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMValidateReq)
}

void IMValidateReq::SharedCtor() {
  user_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  password_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attach_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

IMValidateReq::~IMValidateReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMValidateReq)
  SharedDtor();
}

void IMValidateReq::SharedDtor() {
  user_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  password_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attach_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void IMValidateReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IMValidateReq& IMValidateReq::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_IM_2eServer_2eproto::scc_info_IMValidateReq.base);
  return *internal_default_instance();
}


void IMValidateReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMValidateReq)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      user_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      password_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      attach_data_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool IMValidateReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMValidateReq)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string user_name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required string password = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_password()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(162u /* 162 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMValidateReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMValidateReq)
  return false;
#undef DO_
}

void IMValidateReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMValidateReq)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string user_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->user_name(), output);
  }

  // required string password = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->password(), output);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMValidateReq)
}

size_t IMValidateReq::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Server.IMValidateReq)
  size_t total_size = 0;

  if (has_user_name()) {
    // required string user_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->user_name());
  }

  if (has_password()) {
    // required string password = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->password());
  }

  return total_size;
}
size_t IMValidateReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMValidateReq)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string user_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->user_name());

    // required string password = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->password());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->attach_data());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMValidateReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMValidateReq*>(&from));
}

void IMValidateReq::MergeFrom(const IMValidateReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMValidateReq)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_user_name();
      user_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.user_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_password();
      password_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.password_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_attach_data();
      attach_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.attach_data_);
    }
  }
}

void IMValidateReq::CopyFrom(const IMValidateReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMValidateReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMValidateReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void IMValidateReq::Swap(IMValidateReq* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMValidateReq::InternalSwap(IMValidateReq* other) {
  using std::swap;
  user_name_.Swap(&other->user_name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  password_.Swap(&other->password_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  attach_data_.Swap(&other->attach_data_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string IMValidateReq::GetTypeName() const {
  return "IM.Server.IMValidateReq";
}


// ===================================================================

void IMValidateRsp::InitAsDefaultInstance() {
  ::IM::Server::_IMValidateRsp_default_instance_._instance.get_mutable()->user_info_ = const_cast< ::IM::BaseDefine::UserInfo*>(
      ::IM::BaseDefine::UserInfo::internal_default_instance());
}
void IMValidateRsp::clear_user_info() {
  if (user_info_ != NULL) user_info_->Clear();
  clear_has_user_info();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMValidateRsp::kUserNameFieldNumber;
const int IMValidateRsp::kResultCodeFieldNumber;
const int IMValidateRsp::kResultStringFieldNumber;
const int IMValidateRsp::kUserInfoFieldNumber;
const int IMValidateRsp::kAttachDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMValidateRsp::IMValidateRsp()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_IM_2eServer_2eproto::scc_info_IMValidateRsp.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMValidateRsp)
}
IMValidateRsp::IMValidateRsp(const IMValidateRsp& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  user_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_user_name()) {
    user_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.user_name_);
  }
  result_string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_result_string()) {
    result_string_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.result_string_);
  }
  attach_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_attach_data()) {
    attach_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.attach_data_);
  }
  if (from.has_user_info()) {
    user_info_ = new ::IM::BaseDefine::UserInfo(*from.user_info_);
  } else {
    user_info_ = NULL;
  }
  result_code_ = from.result_code_;
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMValidateRsp)
}

void IMValidateRsp::SharedCtor() {
  user_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  result_string_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attach_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&user_info_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&result_code_) -
      reinterpret_cast<char*>(&user_info_)) + sizeof(result_code_));
}

IMValidateRsp::~IMValidateRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMValidateRsp)
  SharedDtor();
}

void IMValidateRsp::SharedDtor() {
  user_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  result_string_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attach_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete user_info_;
}

void IMValidateRsp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IMValidateRsp& IMValidateRsp::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_IM_2eServer_2eproto::scc_info_IMValidateRsp.base);
  return *internal_default_instance();
}


void IMValidateRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMValidateRsp)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      user_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      result_string_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      attach_data_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(user_info_ != NULL);
      user_info_->Clear();
    }
  }
  result_code_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool IMValidateRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMValidateRsp)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string user_name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 result_code = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_result_code();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_code_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string result_string = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_result_string()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .IM.BaseDefine.UserInfo user_info = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_user_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(162u /* 162 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMValidateRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMValidateRsp)
  return false;
#undef DO_
}

void IMValidateRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMValidateRsp)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string user_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->user_name(), output);
  }

  // required uint32 result_code = 2;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->result_code(), output);
  }

  // optional string result_string = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->result_string(), output);
  }

  // optional .IM.BaseDefine.UserInfo user_info = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->_internal_user_info(), output);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMValidateRsp)
}

size_t IMValidateRsp::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Server.IMValidateRsp)
  size_t total_size = 0;

  if (has_user_name()) {
    // required string user_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->user_name());
  }

  if (has_result_code()) {
    // required uint32 result_code = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->result_code());
  }

  return total_size;
}
size_t IMValidateRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMValidateRsp)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x00000011) ^ 0x00000011) == 0) {  // All required fields are present.
    // required string user_name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->user_name());

    // required uint32 result_code = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->result_code());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[0 / 32] & 14u) {
    // optional string result_string = 3;
    if (has_result_string()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->result_string());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

    // optional .IM.BaseDefine.UserInfo user_info = 4;
    if (has_user_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *user_info_);
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMValidateRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMValidateRsp*>(&from));
}

void IMValidateRsp::MergeFrom(const IMValidateRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMValidateRsp)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 31u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_user_name();
      user_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.user_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_result_string();
      result_string_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.result_string_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_attach_data();
      attach_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.attach_data_);
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_user_info()->::IM::BaseDefine::UserInfo::MergeFrom(from.user_info());
    }
    if (cached_has_bits & 0x00000010u) {
      result_code_ = from.result_code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IMValidateRsp::CopyFrom(const IMValidateRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMValidateRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMValidateRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000011) != 0x00000011) return false;
  if (has_user_info()) {
    if (!this->user_info_->IsInitialized()) return false;
  }
  return true;
}

void IMValidateRsp::Swap(IMValidateRsp* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMValidateRsp::InternalSwap(IMValidateRsp* other) {
  using std::swap;
  user_name_.Swap(&other->user_name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  result_string_.Swap(&other->result_string_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  attach_data_.Swap(&other->attach_data_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(user_info_, other->user_info_);
  swap(result_code_, other->result_code_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string IMValidateRsp::GetTypeName() const {
  return "IM.Server.IMValidateRsp";
}


// ===================================================================

void IMGetDeviceTokenReq::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMGetDeviceTokenReq::kUserIdFieldNumber;
const int IMGetDeviceTokenReq::kAttachDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMGetDeviceTokenReq::IMGetDeviceTokenReq()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_IM_2eServer_2eproto::scc_info_IMGetDeviceTokenReq.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMGetDeviceTokenReq)
}
IMGetDeviceTokenReq::IMGetDeviceTokenReq(const IMGetDeviceTokenReq& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      user_id_(from.user_id_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  attach_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_attach_data()) {
    attach_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.attach_data_);
  }
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMGetDeviceTokenReq)
}

void IMGetDeviceTokenReq::SharedCtor() {
  attach_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

IMGetDeviceTokenReq::~IMGetDeviceTokenReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMGetDeviceTokenReq)
  SharedDtor();
}

void IMGetDeviceTokenReq::SharedDtor() {
  attach_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void IMGetDeviceTokenReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IMGetDeviceTokenReq& IMGetDeviceTokenReq::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_IM_2eServer_2eproto::scc_info_IMGetDeviceTokenReq.base);
  return *internal_default_instance();
}


void IMGetDeviceTokenReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMGetDeviceTokenReq)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_id_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    attach_data_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool IMGetDeviceTokenReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMGetDeviceTokenReq)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated uint32 user_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 8u, input, this->mutable_user_id())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_user_id())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(162u /* 162 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMGetDeviceTokenReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMGetDeviceTokenReq)
  return false;
#undef DO_
}

void IMGetDeviceTokenReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMGetDeviceTokenReq)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 user_id = 1;
  for (int i = 0, n = this->user_id_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      1, this->user_id(i), output);
  }

  cached_has_bits = _has_bits_[0];
  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMGetDeviceTokenReq)
}

size_t IMGetDeviceTokenReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMGetDeviceTokenReq)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated uint32 user_id = 1;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->user_id_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->user_id_size());
    total_size += data_size;
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->attach_data());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMGetDeviceTokenReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGetDeviceTokenReq*>(&from));
}

void IMGetDeviceTokenReq::MergeFrom(const IMGetDeviceTokenReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMGetDeviceTokenReq)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  user_id_.MergeFrom(from.user_id_);
  if (from.has_attach_data()) {
    set_has_attach_data();
    attach_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.attach_data_);
  }
}

void IMGetDeviceTokenReq::CopyFrom(const IMGetDeviceTokenReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMGetDeviceTokenReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGetDeviceTokenReq::IsInitialized() const {
  return true;
}

void IMGetDeviceTokenReq::Swap(IMGetDeviceTokenReq* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMGetDeviceTokenReq::InternalSwap(IMGetDeviceTokenReq* other) {
  using std::swap;
  user_id_.InternalSwap(&other->user_id_);
  attach_data_.Swap(&other->attach_data_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string IMGetDeviceTokenReq::GetTypeName() const {
  return "IM.Server.IMGetDeviceTokenReq";
}


// ===================================================================

void IMGetDeviceTokenRsp::InitAsDefaultInstance() {
}
void IMGetDeviceTokenRsp::clear_user_token_info() {
  user_token_info_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMGetDeviceTokenRsp::kUserTokenInfoFieldNumber;
const int IMGetDeviceTokenRsp::kAttachDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMGetDeviceTokenRsp::IMGetDeviceTokenRsp()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_IM_2eServer_2eproto::scc_info_IMGetDeviceTokenRsp.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMGetDeviceTokenRsp)
}
IMGetDeviceTokenRsp::IMGetDeviceTokenRsp(const IMGetDeviceTokenRsp& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      user_token_info_(from.user_token_info_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  attach_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_attach_data()) {
    attach_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.attach_data_);
  }
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMGetDeviceTokenRsp)
}

void IMGetDeviceTokenRsp::SharedCtor() {
  attach_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

IMGetDeviceTokenRsp::~IMGetDeviceTokenRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMGetDeviceTokenRsp)
  SharedDtor();
}

void IMGetDeviceTokenRsp::SharedDtor() {
  attach_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void IMGetDeviceTokenRsp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IMGetDeviceTokenRsp& IMGetDeviceTokenRsp::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_IM_2eServer_2eproto::scc_info_IMGetDeviceTokenRsp.base);
  return *internal_default_instance();
}


void IMGetDeviceTokenRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMGetDeviceTokenRsp)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_token_info_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    attach_data_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool IMGetDeviceTokenRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMGetDeviceTokenRsp)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .IM.BaseDefine.UserTokenInfo user_token_info = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_user_token_info()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(162u /* 162 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMGetDeviceTokenRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMGetDeviceTokenRsp)
  return false;
#undef DO_
}

void IMGetDeviceTokenRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMGetDeviceTokenRsp)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .IM.BaseDefine.UserTokenInfo user_token_info = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->user_token_info_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1,
      this->user_token_info(static_cast<int>(i)),
      output);
  }

  cached_has_bits = _has_bits_[0];
  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMGetDeviceTokenRsp)
}

size_t IMGetDeviceTokenRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMGetDeviceTokenRsp)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated .IM.BaseDefine.UserTokenInfo user_token_info = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->user_token_info_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->user_token_info(static_cast<int>(i)));
    }
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->attach_data());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMGetDeviceTokenRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGetDeviceTokenRsp*>(&from));
}

void IMGetDeviceTokenRsp::MergeFrom(const IMGetDeviceTokenRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMGetDeviceTokenRsp)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  user_token_info_.MergeFrom(from.user_token_info_);
  if (from.has_attach_data()) {
    set_has_attach_data();
    attach_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.attach_data_);
  }
}

void IMGetDeviceTokenRsp::CopyFrom(const IMGetDeviceTokenRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMGetDeviceTokenRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGetDeviceTokenRsp::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->user_token_info())) return false;
  return true;
}

void IMGetDeviceTokenRsp::Swap(IMGetDeviceTokenRsp* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMGetDeviceTokenRsp::InternalSwap(IMGetDeviceTokenRsp* other) {
  using std::swap;
  CastToBase(&user_token_info_)->InternalSwap(CastToBase(&other->user_token_info_));
  attach_data_.Swap(&other->attach_data_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string IMGetDeviceTokenRsp::GetTypeName() const {
  return "IM.Server.IMGetDeviceTokenRsp";
}


// ===================================================================

void IMRoleSet::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMRoleSet::kMasterFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMRoleSet::IMRoleSet()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_IM_2eServer_2eproto::scc_info_IMRoleSet.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMRoleSet)
}
IMRoleSet::IMRoleSet(const IMRoleSet& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  master_ = from.master_;
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMRoleSet)
}

void IMRoleSet::SharedCtor() {
  master_ = 0u;
}

IMRoleSet::~IMRoleSet() {
  // @@protoc_insertion_point(destructor:IM.Server.IMRoleSet)
  SharedDtor();
}

void IMRoleSet::SharedDtor() {
}

void IMRoleSet::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IMRoleSet& IMRoleSet::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_IM_2eServer_2eproto::scc_info_IMRoleSet.base);
  return *internal_default_instance();
}


void IMRoleSet::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMRoleSet)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  master_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool IMRoleSet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMRoleSet)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 master = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_master();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &master_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMRoleSet)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMRoleSet)
  return false;
#undef DO_
}

void IMRoleSet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMRoleSet)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 master = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->master(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMRoleSet)
}

size_t IMRoleSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMRoleSet)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required uint32 master = 1;
  if (has_master()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->master());
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMRoleSet::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMRoleSet*>(&from));
}

void IMRoleSet::MergeFrom(const IMRoleSet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMRoleSet)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_master()) {
    set_master(from.master());
  }
}

void IMRoleSet::CopyFrom(const IMRoleSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMRoleSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMRoleSet::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  return true;
}

void IMRoleSet::Swap(IMRoleSet* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMRoleSet::InternalSwap(IMRoleSet* other) {
  using std::swap;
  swap(master_, other->master_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string IMRoleSet::GetTypeName() const {
  return "IM.Server.IMRoleSet";
}


// ===================================================================

void IMOnlineUserInfo::InitAsDefaultInstance() {
}
void IMOnlineUserInfo::clear_user_stat_list() {
  user_stat_list_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMOnlineUserInfo::kUserStatListFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMOnlineUserInfo::IMOnlineUserInfo()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_IM_2eServer_2eproto::scc_info_IMOnlineUserInfo.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMOnlineUserInfo)
}
IMOnlineUserInfo::IMOnlineUserInfo(const IMOnlineUserInfo& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      user_stat_list_(from.user_stat_list_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMOnlineUserInfo)
}

void IMOnlineUserInfo::SharedCtor() {
}

IMOnlineUserInfo::~IMOnlineUserInfo() {
  // @@protoc_insertion_point(destructor:IM.Server.IMOnlineUserInfo)
  SharedDtor();
}

void IMOnlineUserInfo::SharedDtor() {
}

void IMOnlineUserInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IMOnlineUserInfo& IMOnlineUserInfo::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_IM_2eServer_2eproto::scc_info_IMOnlineUserInfo.base);
  return *internal_default_instance();
}


void IMOnlineUserInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMOnlineUserInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_stat_list_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool IMOnlineUserInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMOnlineUserInfo)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .IM.BaseDefine.ServerUserStat user_stat_list = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_user_stat_list()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMOnlineUserInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMOnlineUserInfo)
  return false;
#undef DO_
}

void IMOnlineUserInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMOnlineUserInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .IM.BaseDefine.ServerUserStat user_stat_list = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->user_stat_list_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1,
      this->user_stat_list(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMOnlineUserInfo)
}

size_t IMOnlineUserInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMOnlineUserInfo)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated .IM.BaseDefine.ServerUserStat user_stat_list = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->user_stat_list_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->user_stat_list(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMOnlineUserInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMOnlineUserInfo*>(&from));
}

void IMOnlineUserInfo::MergeFrom(const IMOnlineUserInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMOnlineUserInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  user_stat_list_.MergeFrom(from.user_stat_list_);
}

void IMOnlineUserInfo::CopyFrom(const IMOnlineUserInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMOnlineUserInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMOnlineUserInfo::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->user_stat_list())) return false;
  return true;
}

void IMOnlineUserInfo::Swap(IMOnlineUserInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMOnlineUserInfo::InternalSwap(IMOnlineUserInfo* other) {
  using std::swap;
  CastToBase(&user_stat_list_)->InternalSwap(CastToBase(&other->user_stat_list_));
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string IMOnlineUserInfo::GetTypeName() const {
  return "IM.Server.IMOnlineUserInfo";
}


// ===================================================================

void IMMsgServInfo::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMMsgServInfo::kIp1FieldNumber;
const int IMMsgServInfo::kIp2FieldNumber;
const int IMMsgServInfo::kPortFieldNumber;
const int IMMsgServInfo::kMaxConnCntFieldNumber;
const int IMMsgServInfo::kCurConnCntFieldNumber;
const int IMMsgServInfo::kHostNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMMsgServInfo::IMMsgServInfo()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_IM_2eServer_2eproto::scc_info_IMMsgServInfo.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMMsgServInfo)
}
IMMsgServInfo::IMMsgServInfo(const IMMsgServInfo& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ip1_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_ip1()) {
    ip1_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ip1_);
  }
  ip2_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_ip2()) {
    ip2_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ip2_);
  }
  host_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_host_name()) {
    host_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.host_name_);
  }
  ::memcpy(&port_, &from.port_,
    static_cast<size_t>(reinterpret_cast<char*>(&cur_conn_cnt_) -
    reinterpret_cast<char*>(&port_)) + sizeof(cur_conn_cnt_));
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMMsgServInfo)
}

void IMMsgServInfo::SharedCtor() {
  ip1_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ip2_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  host_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&port_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&cur_conn_cnt_) -
      reinterpret_cast<char*>(&port_)) + sizeof(cur_conn_cnt_));
}

IMMsgServInfo::~IMMsgServInfo() {
  // @@protoc_insertion_point(destructor:IM.Server.IMMsgServInfo)
  SharedDtor();
}

void IMMsgServInfo::SharedDtor() {
  ip1_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ip2_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  host_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void IMMsgServInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IMMsgServInfo& IMMsgServInfo::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_IM_2eServer_2eproto::scc_info_IMMsgServInfo.base);
  return *internal_default_instance();
}


void IMMsgServInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMMsgServInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      ip1_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      ip2_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      host_name_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 56u) {
    ::memset(&port_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&cur_conn_cnt_) -
        reinterpret_cast<char*>(&port_)) + sizeof(cur_conn_cnt_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool IMMsgServInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMMsgServInfo)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string ip1 = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip1()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required string ip2 = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip2()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 port = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          set_has_port();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 max_conn_cnt = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          set_has_max_conn_cnt();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &max_conn_cnt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 cur_conn_cnt = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          set_has_cur_conn_cnt();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cur_conn_cnt_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required string host_name = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_host_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMMsgServInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMMsgServInfo)
  return false;
#undef DO_
}

void IMMsgServInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMMsgServInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string ip1 = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->ip1(), output);
  }

  // required string ip2 = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->ip2(), output);
  }

  // required uint32 port = 3;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->port(), output);
  }

  // required uint32 max_conn_cnt = 4;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->max_conn_cnt(), output);
  }

  // required uint32 cur_conn_cnt = 5;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->cur_conn_cnt(), output);
  }

  // required string host_name = 6;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->host_name(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMMsgServInfo)
}

size_t IMMsgServInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Server.IMMsgServInfo)
  size_t total_size = 0;

  if (has_ip1()) {
    // required string ip1 = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->ip1());
  }

  if (has_ip2()) {
    // required string ip2 = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->ip2());
  }

  if (has_host_name()) {
    // required string host_name = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->host_name());
  }

  if (has_port()) {
    // required uint32 port = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->port());
  }

  if (has_max_conn_cnt()) {
    // required uint32 max_conn_cnt = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->max_conn_cnt());
  }

  if (has_cur_conn_cnt()) {
    // required uint32 cur_conn_cnt = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->cur_conn_cnt());
  }

  return total_size;
}
size_t IMMsgServInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMMsgServInfo)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required string ip1 = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->ip1());

    // required string ip2 = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->ip2());

    // required string host_name = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->host_name());

    // required uint32 port = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->port());

    // required uint32 max_conn_cnt = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->max_conn_cnt());

    // required uint32 cur_conn_cnt = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->cur_conn_cnt());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMMsgServInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMMsgServInfo*>(&from));
}

void IMMsgServInfo::MergeFrom(const IMMsgServInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMMsgServInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 63u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_ip1();
      ip1_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ip1_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_ip2();
      ip2_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ip2_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_host_name();
      host_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.host_name_);
    }
    if (cached_has_bits & 0x00000008u) {
      port_ = from.port_;
    }
    if (cached_has_bits & 0x00000010u) {
      max_conn_cnt_ = from.max_conn_cnt_;
    }
    if (cached_has_bits & 0x00000020u) {
      cur_conn_cnt_ = from.cur_conn_cnt_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IMMsgServInfo::CopyFrom(const IMMsgServInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMMsgServInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMMsgServInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003f) != 0x0000003f) return false;
  return true;
}

void IMMsgServInfo::Swap(IMMsgServInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMMsgServInfo::InternalSwap(IMMsgServInfo* other) {
  using std::swap;
  ip1_.Swap(&other->ip1_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  ip2_.Swap(&other->ip2_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  host_name_.Swap(&other->host_name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(port_, other->port_);
  swap(max_conn_cnt_, other->max_conn_cnt_);
  swap(cur_conn_cnt_, other->cur_conn_cnt_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string IMMsgServInfo::GetTypeName() const {
  return "IM.Server.IMMsgServInfo";
}


// ===================================================================

void IMUserStatusUpdate::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMUserStatusUpdate::kUserStatusFieldNumber;
const int IMUserStatusUpdate::kUserIdFieldNumber;
const int IMUserStatusUpdate::kClientTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMUserStatusUpdate::IMUserStatusUpdate()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_IM_2eServer_2eproto::scc_info_IMUserStatusUpdate.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMUserStatusUpdate)
}
IMUserStatusUpdate::IMUserStatusUpdate(const IMUserStatusUpdate& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&user_status_, &from.user_status_,
    static_cast<size_t>(reinterpret_cast<char*>(&client_type_) -
    reinterpret_cast<char*>(&user_status_)) + sizeof(client_type_));
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMUserStatusUpdate)
}

void IMUserStatusUpdate::SharedCtor() {
  ::memset(&user_status_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&user_id_) -
      reinterpret_cast<char*>(&user_status_)) + sizeof(user_id_));
  client_type_ = 1;
}

IMUserStatusUpdate::~IMUserStatusUpdate() {
  // @@protoc_insertion_point(destructor:IM.Server.IMUserStatusUpdate)
  SharedDtor();
}

void IMUserStatusUpdate::SharedDtor() {
}

void IMUserStatusUpdate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IMUserStatusUpdate& IMUserStatusUpdate::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_IM_2eServer_2eproto::scc_info_IMUserStatusUpdate.base);
  return *internal_default_instance();
}


void IMUserStatusUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMUserStatusUpdate)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    ::memset(&user_status_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&user_id_) -
        reinterpret_cast<char*>(&user_status_)) + sizeof(user_id_));
    client_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool IMUserStatusUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMUserStatusUpdate)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_status = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_user_status();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_status_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_user_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .IM.BaseDefine.ClientType client_type = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::ClientType_IsValid(value)) {
            set_client_type(static_cast< ::IM::BaseDefine::ClientType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(24u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMUserStatusUpdate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMUserStatusUpdate)
  return false;
#undef DO_
}

void IMUserStatusUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMUserStatusUpdate)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_status = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_status(), output);
  }

  // required uint32 user_id = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

  // required .IM.BaseDefine.ClientType client_type = 3;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->client_type(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMUserStatusUpdate)
}

size_t IMUserStatusUpdate::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Server.IMUserStatusUpdate)
  size_t total_size = 0;

  if (has_user_status()) {
    // required uint32 user_status = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->user_status());
  }

  if (has_user_id()) {
    // required uint32 user_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->user_id());
  }

  if (has_client_type()) {
    // required .IM.BaseDefine.ClientType client_type = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->client_type());
  }

  return total_size;
}
size_t IMUserStatusUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMUserStatusUpdate)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 user_status = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->user_status());

    // required uint32 user_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->user_id());

    // required .IM.BaseDefine.ClientType client_type = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->client_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMUserStatusUpdate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMUserStatusUpdate*>(&from));
}

void IMUserStatusUpdate::MergeFrom(const IMUserStatusUpdate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMUserStatusUpdate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      user_status_ = from.user_status_;
    }
    if (cached_has_bits & 0x00000002u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      client_type_ = from.client_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IMUserStatusUpdate::CopyFrom(const IMUserStatusUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMUserStatusUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMUserStatusUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  return true;
}

void IMUserStatusUpdate::Swap(IMUserStatusUpdate* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMUserStatusUpdate::InternalSwap(IMUserStatusUpdate* other) {
  using std::swap;
  swap(user_status_, other->user_status_);
  swap(user_id_, other->user_id_);
  swap(client_type_, other->client_type_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string IMUserStatusUpdate::GetTypeName() const {
  return "IM.Server.IMUserStatusUpdate";
}


// ===================================================================

void IMUserCntUpdate::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMUserCntUpdate::kUserActionFieldNumber;
const int IMUserCntUpdate::kUserIdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMUserCntUpdate::IMUserCntUpdate()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_IM_2eServer_2eproto::scc_info_IMUserCntUpdate.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMUserCntUpdate)
}
IMUserCntUpdate::IMUserCntUpdate(const IMUserCntUpdate& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&user_action_, &from.user_action_,
    static_cast<size_t>(reinterpret_cast<char*>(&user_id_) -
    reinterpret_cast<char*>(&user_action_)) + sizeof(user_id_));
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMUserCntUpdate)
}

void IMUserCntUpdate::SharedCtor() {
  ::memset(&user_action_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&user_id_) -
      reinterpret_cast<char*>(&user_action_)) + sizeof(user_id_));
}

IMUserCntUpdate::~IMUserCntUpdate() {
  // @@protoc_insertion_point(destructor:IM.Server.IMUserCntUpdate)
  SharedDtor();
}

void IMUserCntUpdate::SharedDtor() {
}

void IMUserCntUpdate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IMUserCntUpdate& IMUserCntUpdate::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_IM_2eServer_2eproto::scc_info_IMUserCntUpdate.base);
  return *internal_default_instance();
}


void IMUserCntUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMUserCntUpdate)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    ::memset(&user_action_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&user_id_) -
        reinterpret_cast<char*>(&user_action_)) + sizeof(user_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool IMUserCntUpdate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMUserCntUpdate)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_action = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_user_action();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_action_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 user_id = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_user_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMUserCntUpdate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMUserCntUpdate)
  return false;
#undef DO_
}

void IMUserCntUpdate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMUserCntUpdate)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_action = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_action(), output);
  }

  // required uint32 user_id = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->user_id(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMUserCntUpdate)
}

size_t IMUserCntUpdate::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Server.IMUserCntUpdate)
  size_t total_size = 0;

  if (has_user_action()) {
    // required uint32 user_action = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->user_action());
  }

  if (has_user_id()) {
    // required uint32 user_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->user_id());
  }

  return total_size;
}
size_t IMUserCntUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMUserCntUpdate)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 user_action = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->user_action());

    // required uint32 user_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->user_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMUserCntUpdate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMUserCntUpdate*>(&from));
}

void IMUserCntUpdate::MergeFrom(const IMUserCntUpdate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMUserCntUpdate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      user_action_ = from.user_action_;
    }
    if (cached_has_bits & 0x00000002u) {
      user_id_ = from.user_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IMUserCntUpdate::CopyFrom(const IMUserCntUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMUserCntUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMUserCntUpdate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void IMUserCntUpdate::Swap(IMUserCntUpdate* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMUserCntUpdate::InternalSwap(IMUserCntUpdate* other) {
  using std::swap;
  swap(user_action_, other->user_action_);
  swap(user_id_, other->user_id_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string IMUserCntUpdate::GetTypeName() const {
  return "IM.Server.IMUserCntUpdate";
}


// ===================================================================

void IMServerKickUser::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMServerKickUser::kUserIdFieldNumber;
const int IMServerKickUser::kClientTypeFieldNumber;
const int IMServerKickUser::kReasonFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMServerKickUser::IMServerKickUser()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_IM_2eServer_2eproto::scc_info_IMServerKickUser.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMServerKickUser)
}
IMServerKickUser::IMServerKickUser(const IMServerKickUser& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&client_type_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(client_type_));
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMServerKickUser)
}

void IMServerKickUser::SharedCtor() {
  ::memset(&user_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&reason_) -
      reinterpret_cast<char*>(&user_id_)) + sizeof(reason_));
  client_type_ = 1;
}

IMServerKickUser::~IMServerKickUser() {
  // @@protoc_insertion_point(destructor:IM.Server.IMServerKickUser)
  SharedDtor();
}

void IMServerKickUser::SharedDtor() {
}

void IMServerKickUser::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IMServerKickUser& IMServerKickUser::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_IM_2eServer_2eproto::scc_info_IMServerKickUser.base);
  return *internal_default_instance();
}


void IMServerKickUser::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMServerKickUser)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    ::memset(&user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&reason_) -
        reinterpret_cast<char*>(&user_id_)) + sizeof(reason_));
    client_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool IMServerKickUser::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMServerKickUser)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_user_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .IM.BaseDefine.ClientType client_type = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::ClientType_IsValid(value)) {
            set_client_type(static_cast< ::IM::BaseDefine::ClientType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(16u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 reason = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          set_has_reason();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &reason_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMServerKickUser)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMServerKickUser)
  return false;
#undef DO_
}

void IMServerKickUser::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMServerKickUser)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required .IM.BaseDefine.ClientType client_type = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->client_type(), output);
  }

  // required uint32 reason = 3;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->reason(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMServerKickUser)
}

size_t IMServerKickUser::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Server.IMServerKickUser)
  size_t total_size = 0;

  if (has_user_id()) {
    // required uint32 user_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->user_id());
  }

  if (has_reason()) {
    // required uint32 reason = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->reason());
  }

  if (has_client_type()) {
    // required .IM.BaseDefine.ClientType client_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->client_type());
  }

  return total_size;
}
size_t IMServerKickUser::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMServerKickUser)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->user_id());

    // required uint32 reason = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->reason());

    // required .IM.BaseDefine.ClientType client_type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->client_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMServerKickUser::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMServerKickUser*>(&from));
}

void IMServerKickUser::MergeFrom(const IMServerKickUser& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMServerKickUser)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      reason_ = from.reason_;
    }
    if (cached_has_bits & 0x00000004u) {
      client_type_ = from.client_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IMServerKickUser::CopyFrom(const IMServerKickUser& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMServerKickUser)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMServerKickUser::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;
  return true;
}

void IMServerKickUser::Swap(IMServerKickUser* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMServerKickUser::InternalSwap(IMServerKickUser* other) {
  using std::swap;
  swap(user_id_, other->user_id_);
  swap(reason_, other->reason_);
  swap(client_type_, other->client_type_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string IMServerKickUser::GetTypeName() const {
  return "IM.Server.IMServerKickUser";
}


// ===================================================================

void IMServerPCLoginStatusNotify::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMServerPCLoginStatusNotify::kUserIdFieldNumber;
const int IMServerPCLoginStatusNotify::kLoginStatusFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMServerPCLoginStatusNotify::IMServerPCLoginStatusNotify()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_IM_2eServer_2eproto::scc_info_IMServerPCLoginStatusNotify.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMServerPCLoginStatusNotify)
}
IMServerPCLoginStatusNotify::IMServerPCLoginStatusNotify(const IMServerPCLoginStatusNotify& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&login_status_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(login_status_));
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMServerPCLoginStatusNotify)
}

void IMServerPCLoginStatusNotify::SharedCtor() {
  ::memset(&user_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&login_status_) -
      reinterpret_cast<char*>(&user_id_)) + sizeof(login_status_));
}

IMServerPCLoginStatusNotify::~IMServerPCLoginStatusNotify() {
  // @@protoc_insertion_point(destructor:IM.Server.IMServerPCLoginStatusNotify)
  SharedDtor();
}

void IMServerPCLoginStatusNotify::SharedDtor() {
}

void IMServerPCLoginStatusNotify::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IMServerPCLoginStatusNotify& IMServerPCLoginStatusNotify::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_IM_2eServer_2eproto::scc_info_IMServerPCLoginStatusNotify.base);
  return *internal_default_instance();
}


void IMServerPCLoginStatusNotify::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMServerPCLoginStatusNotify)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    ::memset(&user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&login_status_) -
        reinterpret_cast<char*>(&user_id_)) + sizeof(login_status_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool IMServerPCLoginStatusNotify::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMServerPCLoginStatusNotify)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 user_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_user_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &user_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 login_status = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_login_status();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &login_status_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMServerPCLoginStatusNotify)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMServerPCLoginStatusNotify)
  return false;
#undef DO_
}

void IMServerPCLoginStatusNotify::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMServerPCLoginStatusNotify)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 user_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->user_id(), output);
  }

  // required uint32 login_status = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->login_status(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMServerPCLoginStatusNotify)
}

size_t IMServerPCLoginStatusNotify::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Server.IMServerPCLoginStatusNotify)
  size_t total_size = 0;

  if (has_user_id()) {
    // required uint32 user_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->user_id());
  }

  if (has_login_status()) {
    // required uint32 login_status = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->login_status());
  }

  return total_size;
}
size_t IMServerPCLoginStatusNotify::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMServerPCLoginStatusNotify)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 user_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->user_id());

    // required uint32 login_status = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->login_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMServerPCLoginStatusNotify::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMServerPCLoginStatusNotify*>(&from));
}

void IMServerPCLoginStatusNotify::MergeFrom(const IMServerPCLoginStatusNotify& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMServerPCLoginStatusNotify)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      user_id_ = from.user_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      login_status_ = from.login_status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IMServerPCLoginStatusNotify::CopyFrom(const IMServerPCLoginStatusNotify& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMServerPCLoginStatusNotify)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMServerPCLoginStatusNotify::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void IMServerPCLoginStatusNotify::Swap(IMServerPCLoginStatusNotify* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMServerPCLoginStatusNotify::InternalSwap(IMServerPCLoginStatusNotify* other) {
  using std::swap;
  swap(user_id_, other->user_id_);
  swap(login_status_, other->login_status_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string IMServerPCLoginStatusNotify::GetTypeName() const {
  return "IM.Server.IMServerPCLoginStatusNotify";
}


// ===================================================================

void IMPushToUserReq::InitAsDefaultInstance() {
}
void IMPushToUserReq::clear_user_token_list() {
  user_token_list_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMPushToUserReq::kFlashFieldNumber;
const int IMPushToUserReq::kDataFieldNumber;
const int IMPushToUserReq::kUserTokenListFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMPushToUserReq::IMPushToUserReq()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_IM_2eServer_2eproto::scc_info_IMPushToUserReq.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMPushToUserReq)
}
IMPushToUserReq::IMPushToUserReq(const IMPushToUserReq& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      user_token_list_(from.user_token_list_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  flash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_flash()) {
    flash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.flash_);
  }
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_data()) {
    data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
  }
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMPushToUserReq)
}

void IMPushToUserReq::SharedCtor() {
  flash_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

IMPushToUserReq::~IMPushToUserReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMPushToUserReq)
  SharedDtor();
}

void IMPushToUserReq::SharedDtor() {
  flash_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void IMPushToUserReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IMPushToUserReq& IMPushToUserReq::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_IM_2eServer_2eproto::scc_info_IMPushToUserReq.base);
  return *internal_default_instance();
}


void IMPushToUserReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMPushToUserReq)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_token_list_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      flash_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      data_.ClearNonDefaultToEmptyNoArena();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool IMPushToUserReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMPushToUserReq)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string flash = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_flash()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required string data = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .IM.BaseDefine.UserTokenInfo user_token_list = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_user_token_list()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMPushToUserReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMPushToUserReq)
  return false;
#undef DO_
}

void IMPushToUserReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMPushToUserReq)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string flash = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->flash(), output);
  }

  // required string data = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->data(), output);
  }

  // repeated .IM.BaseDefine.UserTokenInfo user_token_list = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->user_token_list_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3,
      this->user_token_list(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMPushToUserReq)
}

size_t IMPushToUserReq::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Server.IMPushToUserReq)
  size_t total_size = 0;

  if (has_flash()) {
    // required string flash = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->flash());
  }

  if (has_data()) {
    // required string data = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->data());
  }

  return total_size;
}
size_t IMPushToUserReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMPushToUserReq)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string flash = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->flash());

    // required string data = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->data());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // repeated .IM.BaseDefine.UserTokenInfo user_token_list = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->user_token_list_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->user_token_list(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMPushToUserReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMPushToUserReq*>(&from));
}

void IMPushToUserReq::MergeFrom(const IMPushToUserReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMPushToUserReq)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  user_token_list_.MergeFrom(from.user_token_list_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_flash();
      flash_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.flash_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_data();
      data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
    }
  }
}

void IMPushToUserReq::CopyFrom(const IMPushToUserReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMPushToUserReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMPushToUserReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->user_token_list())) return false;
  return true;
}

void IMPushToUserReq::Swap(IMPushToUserReq* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMPushToUserReq::InternalSwap(IMPushToUserReq* other) {
  using std::swap;
  CastToBase(&user_token_list_)->InternalSwap(CastToBase(&other->user_token_list_));
  flash_.Swap(&other->flash_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  data_.Swap(&other->data_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string IMPushToUserReq::GetTypeName() const {
  return "IM.Server.IMPushToUserReq";
}


// ===================================================================

void IMPushToUserRsp::InitAsDefaultInstance() {
}
void IMPushToUserRsp::clear_push_result_list() {
  push_result_list_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMPushToUserRsp::kPushResultListFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMPushToUserRsp::IMPushToUserRsp()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_IM_2eServer_2eproto::scc_info_IMPushToUserRsp.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMPushToUserRsp)
}
IMPushToUserRsp::IMPushToUserRsp(const IMPushToUserRsp& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      push_result_list_(from.push_result_list_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMPushToUserRsp)
}

void IMPushToUserRsp::SharedCtor() {
}

IMPushToUserRsp::~IMPushToUserRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMPushToUserRsp)
  SharedDtor();
}

void IMPushToUserRsp::SharedDtor() {
}

void IMPushToUserRsp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IMPushToUserRsp& IMPushToUserRsp::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_IM_2eServer_2eproto::scc_info_IMPushToUserRsp.base);
  return *internal_default_instance();
}


void IMPushToUserRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMPushToUserRsp)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  push_result_list_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool IMPushToUserRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMPushToUserRsp)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .IM.BaseDefine.PushResult push_result_list = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_push_result_list()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMPushToUserRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMPushToUserRsp)
  return false;
#undef DO_
}

void IMPushToUserRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMPushToUserRsp)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .IM.BaseDefine.PushResult push_result_list = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->push_result_list_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1,
      this->push_result_list(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMPushToUserRsp)
}

size_t IMPushToUserRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMPushToUserRsp)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated .IM.BaseDefine.PushResult push_result_list = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->push_result_list_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->push_result_list(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMPushToUserRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMPushToUserRsp*>(&from));
}

void IMPushToUserRsp::MergeFrom(const IMPushToUserRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMPushToUserRsp)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  push_result_list_.MergeFrom(from.push_result_list_);
}

void IMPushToUserRsp::CopyFrom(const IMPushToUserRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMPushToUserRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMPushToUserRsp::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->push_result_list())) return false;
  return true;
}

void IMPushToUserRsp::Swap(IMPushToUserRsp* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMPushToUserRsp::InternalSwap(IMPushToUserRsp* other) {
  using std::swap;
  CastToBase(&push_result_list_)->InternalSwap(CastToBase(&other->push_result_list_));
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string IMPushToUserRsp::GetTypeName() const {
  return "IM.Server.IMPushToUserRsp";
}


// ===================================================================

void IMGroupGetShieldReq::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMGroupGetShieldReq::kGroupIdFieldNumber;
const int IMGroupGetShieldReq::kUserIdFieldNumber;
const int IMGroupGetShieldReq::kAttachDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMGroupGetShieldReq::IMGroupGetShieldReq()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_IM_2eServer_2eproto::scc_info_IMGroupGetShieldReq.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMGroupGetShieldReq)
}
IMGroupGetShieldReq::IMGroupGetShieldReq(const IMGroupGetShieldReq& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      user_id_(from.user_id_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  attach_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_attach_data()) {
    attach_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.attach_data_);
  }
  group_id_ = from.group_id_;
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMGroupGetShieldReq)
}

void IMGroupGetShieldReq::SharedCtor() {
  attach_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  group_id_ = 0u;
}

IMGroupGetShieldReq::~IMGroupGetShieldReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMGroupGetShieldReq)
  SharedDtor();
}

void IMGroupGetShieldReq::SharedDtor() {
  attach_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void IMGroupGetShieldReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IMGroupGetShieldReq& IMGroupGetShieldReq::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_IM_2eServer_2eproto::scc_info_IMGroupGetShieldReq.base);
  return *internal_default_instance();
}


void IMGroupGetShieldReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMGroupGetShieldReq)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_id_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    attach_data_.ClearNonDefaultToEmptyNoArena();
  }
  group_id_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool IMGroupGetShieldReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMGroupGetShieldReq)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 group_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_group_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated uint32 user_id = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 16u, input, this->mutable_user_id())));
        } else if (
            static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_user_id())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(162u /* 162 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMGroupGetShieldReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMGroupGetShieldReq)
  return false;
#undef DO_
}

void IMGroupGetShieldReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMGroupGetShieldReq)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 group_id = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->group_id(), output);
  }

  // repeated uint32 user_id = 2;
  for (int i = 0, n = this->user_id_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      2, this->user_id(i), output);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMGroupGetShieldReq)
}

size_t IMGroupGetShieldReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMGroupGetShieldReq)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required uint32 group_id = 1;
  if (has_group_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->group_id());
  }
  // repeated uint32 user_id = 2;
  {
    size_t data_size = ::google::protobuf::internal::WireFormatLite::
      UInt32Size(this->user_id_);
    total_size += 1 *
                  ::google::protobuf::internal::FromIntSize(this->user_id_size());
    total_size += data_size;
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->attach_data());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMGroupGetShieldReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGroupGetShieldReq*>(&from));
}

void IMGroupGetShieldReq::MergeFrom(const IMGroupGetShieldReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMGroupGetShieldReq)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  user_id_.MergeFrom(from.user_id_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_attach_data();
      attach_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.attach_data_);
    }
    if (cached_has_bits & 0x00000002u) {
      group_id_ = from.group_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IMGroupGetShieldReq::CopyFrom(const IMGroupGetShieldReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMGroupGetShieldReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGroupGetShieldReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  return true;
}

void IMGroupGetShieldReq::Swap(IMGroupGetShieldReq* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMGroupGetShieldReq::InternalSwap(IMGroupGetShieldReq* other) {
  using std::swap;
  user_id_.InternalSwap(&other->user_id_);
  attach_data_.Swap(&other->attach_data_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(group_id_, other->group_id_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string IMGroupGetShieldReq::GetTypeName() const {
  return "IM.Server.IMGroupGetShieldReq";
}


// ===================================================================

void IMGroupGetShieldRsp::InitAsDefaultInstance() {
}
void IMGroupGetShieldRsp::clear_shield_status_list() {
  shield_status_list_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMGroupGetShieldRsp::kGroupIdFieldNumber;
const int IMGroupGetShieldRsp::kShieldStatusListFieldNumber;
const int IMGroupGetShieldRsp::kAttachDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMGroupGetShieldRsp::IMGroupGetShieldRsp()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_IM_2eServer_2eproto::scc_info_IMGroupGetShieldRsp.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMGroupGetShieldRsp)
}
IMGroupGetShieldRsp::IMGroupGetShieldRsp(const IMGroupGetShieldRsp& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      shield_status_list_(from.shield_status_list_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  attach_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_attach_data()) {
    attach_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.attach_data_);
  }
  group_id_ = from.group_id_;
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMGroupGetShieldRsp)
}

void IMGroupGetShieldRsp::SharedCtor() {
  attach_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  group_id_ = 0u;
}

IMGroupGetShieldRsp::~IMGroupGetShieldRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMGroupGetShieldRsp)
  SharedDtor();
}

void IMGroupGetShieldRsp::SharedDtor() {
  attach_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void IMGroupGetShieldRsp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IMGroupGetShieldRsp& IMGroupGetShieldRsp::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_IM_2eServer_2eproto::scc_info_IMGroupGetShieldRsp.base);
  return *internal_default_instance();
}


void IMGroupGetShieldRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMGroupGetShieldRsp)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  shield_status_list_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    attach_data_.ClearNonDefaultToEmptyNoArena();
  }
  group_id_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool IMGroupGetShieldRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMGroupGetShieldRsp)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 group_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_group_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &group_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .IM.BaseDefine.ShieldStatus shield_status_list = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_shield_status_list()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(162u /* 162 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMGroupGetShieldRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMGroupGetShieldRsp)
  return false;
#undef DO_
}

void IMGroupGetShieldRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMGroupGetShieldRsp)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 group_id = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->group_id(), output);
  }

  // repeated .IM.BaseDefine.ShieldStatus shield_status_list = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->shield_status_list_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2,
      this->shield_status_list(static_cast<int>(i)),
      output);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMGroupGetShieldRsp)
}

size_t IMGroupGetShieldRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMGroupGetShieldRsp)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // required uint32 group_id = 1;
  if (has_group_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->group_id());
  }
  // repeated .IM.BaseDefine.ShieldStatus shield_status_list = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->shield_status_list_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->shield_status_list(static_cast<int>(i)));
    }
  }

  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->attach_data());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMGroupGetShieldRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMGroupGetShieldRsp*>(&from));
}

void IMGroupGetShieldRsp::MergeFrom(const IMGroupGetShieldRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMGroupGetShieldRsp)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  shield_status_list_.MergeFrom(from.shield_status_list_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_attach_data();
      attach_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.attach_data_);
    }
    if (cached_has_bits & 0x00000002u) {
      group_id_ = from.group_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IMGroupGetShieldRsp::CopyFrom(const IMGroupGetShieldRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMGroupGetShieldRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMGroupGetShieldRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->shield_status_list())) return false;
  return true;
}

void IMGroupGetShieldRsp::Swap(IMGroupGetShieldRsp* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMGroupGetShieldRsp::InternalSwap(IMGroupGetShieldRsp* other) {
  using std::swap;
  CastToBase(&shield_status_list_)->InternalSwap(CastToBase(&other->shield_status_list_));
  attach_data_.Swap(&other->attach_data_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(group_id_, other->group_id_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string IMGroupGetShieldRsp::GetTypeName() const {
  return "IM.Server.IMGroupGetShieldRsp";
}


// ===================================================================

void IMFileTransferReq::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMFileTransferReq::kFromUserIdFieldNumber;
const int IMFileTransferReq::kToUserIdFieldNumber;
const int IMFileTransferReq::kFileNameFieldNumber;
const int IMFileTransferReq::kFileSizeFieldNumber;
const int IMFileTransferReq::kTransModeFieldNumber;
const int IMFileTransferReq::kAttachDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMFileTransferReq::IMFileTransferReq()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_IM_2eServer_2eproto::scc_info_IMFileTransferReq.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMFileTransferReq)
}
IMFileTransferReq::IMFileTransferReq(const IMFileTransferReq& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  file_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_file_name()) {
    file_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.file_name_);
  }
  attach_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_attach_data()) {
    attach_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.attach_data_);
  }
  ::memcpy(&from_user_id_, &from.from_user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&trans_mode_) -
    reinterpret_cast<char*>(&from_user_id_)) + sizeof(trans_mode_));
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMFileTransferReq)
}

void IMFileTransferReq::SharedCtor() {
  file_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attach_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&from_user_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&file_size_) -
      reinterpret_cast<char*>(&from_user_id_)) + sizeof(file_size_));
  trans_mode_ = 1;
}

IMFileTransferReq::~IMFileTransferReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMFileTransferReq)
  SharedDtor();
}

void IMFileTransferReq::SharedDtor() {
  file_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attach_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void IMFileTransferReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IMFileTransferReq& IMFileTransferReq::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_IM_2eServer_2eproto::scc_info_IMFileTransferReq.base);
  return *internal_default_instance();
}


void IMFileTransferReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMFileTransferReq)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      file_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      attach_data_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 60u) {
    ::memset(&from_user_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&file_size_) -
        reinterpret_cast<char*>(&from_user_id_)) + sizeof(file_size_));
    trans_mode_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool IMFileTransferReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMFileTransferReq)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 from_user_id = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_from_user_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 to_user_id = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_to_user_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_user_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required string file_name = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_file_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 file_size = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          set_has_file_size();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &file_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .IM.BaseDefine.TransferFileType trans_mode = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::TransferFileType_IsValid(value)) {
            set_trans_mode(static_cast< ::IM::BaseDefine::TransferFileType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(40u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(162u /* 162 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMFileTransferReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMFileTransferReq)
  return false;
#undef DO_
}

void IMFileTransferReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMFileTransferReq)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 from_user_id = 1;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->from_user_id(), output);
  }

  // required uint32 to_user_id = 2;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->to_user_id(), output);
  }

  // required string file_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->file_name(), output);
  }

  // required uint32 file_size = 4;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->file_size(), output);
  }

  // required .IM.BaseDefine.TransferFileType trans_mode = 5;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      5, this->trans_mode(), output);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMFileTransferReq)
}

size_t IMFileTransferReq::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Server.IMFileTransferReq)
  size_t total_size = 0;

  if (has_file_name()) {
    // required string file_name = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->file_name());
  }

  if (has_from_user_id()) {
    // required uint32 from_user_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->from_user_id());
  }

  if (has_to_user_id()) {
    // required uint32 to_user_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->to_user_id());
  }

  if (has_file_size()) {
    // required uint32 file_size = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->file_size());
  }

  if (has_trans_mode()) {
    // required .IM.BaseDefine.TransferFileType trans_mode = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->trans_mode());
  }

  return total_size;
}
size_t IMFileTransferReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMFileTransferReq)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x0000003d) ^ 0x0000003d) == 0) {  // All required fields are present.
    // required string file_name = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->file_name());

    // required uint32 from_user_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->from_user_id());

    // required uint32 to_user_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->to_user_id());

    // required uint32 file_size = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->file_size());

    // required .IM.BaseDefine.TransferFileType trans_mode = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->trans_mode());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional bytes attach_data = 20;
  if (has_attach_data()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->attach_data());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMFileTransferReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileTransferReq*>(&from));
}

void IMFileTransferReq::MergeFrom(const IMFileTransferReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMFileTransferReq)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 63u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_file_name();
      file_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.file_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_attach_data();
      attach_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.attach_data_);
    }
    if (cached_has_bits & 0x00000004u) {
      from_user_id_ = from.from_user_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      to_user_id_ = from.to_user_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      file_size_ = from.file_size_;
    }
    if (cached_has_bits & 0x00000020u) {
      trans_mode_ = from.trans_mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IMFileTransferReq::CopyFrom(const IMFileTransferReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMFileTransferReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileTransferReq::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000003d) != 0x0000003d) return false;
  return true;
}

void IMFileTransferReq::Swap(IMFileTransferReq* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMFileTransferReq::InternalSwap(IMFileTransferReq* other) {
  using std::swap;
  file_name_.Swap(&other->file_name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  attach_data_.Swap(&other->attach_data_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(from_user_id_, other->from_user_id_);
  swap(to_user_id_, other->to_user_id_);
  swap(file_size_, other->file_size_);
  swap(trans_mode_, other->trans_mode_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string IMFileTransferReq::GetTypeName() const {
  return "IM.Server.IMFileTransferReq";
}


// ===================================================================

void IMFileTransferRsp::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMFileTransferRsp::kResultCodeFieldNumber;
const int IMFileTransferRsp::kFromUserIdFieldNumber;
const int IMFileTransferRsp::kToUserIdFieldNumber;
const int IMFileTransferRsp::kFileNameFieldNumber;
const int IMFileTransferRsp::kFileSizeFieldNumber;
const int IMFileTransferRsp::kTaskIdFieldNumber;
const int IMFileTransferRsp::kTransModeFieldNumber;
const int IMFileTransferRsp::kAttachDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMFileTransferRsp::IMFileTransferRsp()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_IM_2eServer_2eproto::scc_info_IMFileTransferRsp.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMFileTransferRsp)
}
IMFileTransferRsp::IMFileTransferRsp(const IMFileTransferRsp& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  file_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_file_name()) {
    file_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.file_name_);
  }
  task_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_task_id()) {
    task_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.task_id_);
  }
  attach_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_attach_data()) {
    attach_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.attach_data_);
  }
  ::memcpy(&result_code_, &from.result_code_,
    static_cast<size_t>(reinterpret_cast<char*>(&trans_mode_) -
    reinterpret_cast<char*>(&result_code_)) + sizeof(trans_mode_));
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMFileTransferRsp)
}

void IMFileTransferRsp::SharedCtor() {
  file_name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  task_id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attach_data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&result_code_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&file_size_) -
      reinterpret_cast<char*>(&result_code_)) + sizeof(file_size_));
  trans_mode_ = 1;
}

IMFileTransferRsp::~IMFileTransferRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMFileTransferRsp)
  SharedDtor();
}

void IMFileTransferRsp::SharedDtor() {
  file_name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  task_id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  attach_data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void IMFileTransferRsp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IMFileTransferRsp& IMFileTransferRsp::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_IM_2eServer_2eproto::scc_info_IMFileTransferRsp.base);
  return *internal_default_instance();
}


void IMFileTransferRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMFileTransferRsp)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 7u) {
    if (cached_has_bits & 0x00000001u) {
      file_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      task_id_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      attach_data_.ClearNonDefaultToEmptyNoArena();
    }
  }
  if (cached_has_bits & 248u) {
    ::memset(&result_code_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&file_size_) -
        reinterpret_cast<char*>(&result_code_)) + sizeof(file_size_));
    trans_mode_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool IMFileTransferRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMFileTransferRsp)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 result_code = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_result_code();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &result_code_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 from_user_id = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_from_user_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &from_user_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 to_user_id = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          set_has_to_user_id();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &to_user_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string file_name = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(34u /* 34 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_file_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 file_size = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          set_has_file_size();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &file_size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string task_id = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_task_id()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .IM.BaseDefine.TransferFileType trans_mode = 7;
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(56u /* 56 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::IM::BaseDefine::TransferFileType_IsValid(value)) {
            set_trans_mode(static_cast< ::IM::BaseDefine::TransferFileType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(56u);
            unknown_fields_stream.WriteVarint32(
                static_cast< ::google::protobuf::uint32>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes attach_data = 20;
      case 20: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(162u /* 162 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_attach_data()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMFileTransferRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMFileTransferRsp)
  return false;
#undef DO_
}

void IMFileTransferRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMFileTransferRsp)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 result_code = 1;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->result_code(), output);
  }

  // required uint32 from_user_id = 2;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->from_user_id(), output);
  }

  // required uint32 to_user_id = 3;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->to_user_id(), output);
  }

  // optional string file_name = 4;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->file_name(), output);
  }

  // optional uint32 file_size = 5;
  if (cached_has_bits & 0x00000040u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->file_size(), output);
  }

  // optional string task_id = 6;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->task_id(), output);
  }

  // optional .IM.BaseDefine.TransferFileType trans_mode = 7;
  if (cached_has_bits & 0x00000080u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      7, this->trans_mode(), output);
  }

  // optional bytes attach_data = 20;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      20, this->attach_data(), output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMFileTransferRsp)
}

size_t IMFileTransferRsp::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IM.Server.IMFileTransferRsp)
  size_t total_size = 0;

  if (has_result_code()) {
    // required uint32 result_code = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->result_code());
  }

  if (has_from_user_id()) {
    // required uint32 from_user_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->from_user_id());
  }

  if (has_to_user_id()) {
    // required uint32 to_user_id = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->to_user_id());
  }

  return total_size;
}
size_t IMFileTransferRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMFileTransferRsp)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  if (((_has_bits_[0] & 0x00000038) ^ 0x00000038) == 0) {  // All required fields are present.
    // required uint32 result_code = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->result_code());

    // required uint32 from_user_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->from_user_id());

    // required uint32 to_user_id = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->to_user_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[0 / 32] & 7u) {
    // optional string file_name = 4;
    if (has_file_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->file_name());
    }

    // optional string task_id = 6;
    if (has_task_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->task_id());
    }

    // optional bytes attach_data = 20;
    if (has_attach_data()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->attach_data());
    }

  }
  if (_has_bits_[0 / 32] & 192u) {
    // optional uint32 file_size = 5;
    if (has_file_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->file_size());
    }

    // optional .IM.BaseDefine.TransferFileType trans_mode = 7;
    if (has_trans_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->trans_mode());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMFileTransferRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileTransferRsp*>(&from));
}

void IMFileTransferRsp::MergeFrom(const IMFileTransferRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMFileTransferRsp)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 255u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_file_name();
      file_name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.file_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      set_has_task_id();
      task_id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.task_id_);
    }
    if (cached_has_bits & 0x00000004u) {
      set_has_attach_data();
      attach_data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.attach_data_);
    }
    if (cached_has_bits & 0x00000008u) {
      result_code_ = from.result_code_;
    }
    if (cached_has_bits & 0x00000010u) {
      from_user_id_ = from.from_user_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      to_user_id_ = from.to_user_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      file_size_ = from.file_size_;
    }
    if (cached_has_bits & 0x00000080u) {
      trans_mode_ = from.trans_mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IMFileTransferRsp::CopyFrom(const IMFileTransferRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMFileTransferRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileTransferRsp::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000038) != 0x00000038) return false;
  return true;
}

void IMFileTransferRsp::Swap(IMFileTransferRsp* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMFileTransferRsp::InternalSwap(IMFileTransferRsp* other) {
  using std::swap;
  file_name_.Swap(&other->file_name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  task_id_.Swap(&other->task_id_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  attach_data_.Swap(&other->attach_data_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(result_code_, other->result_code_);
  swap(from_user_id_, other->from_user_id_);
  swap(to_user_id_, other->to_user_id_);
  swap(file_size_, other->file_size_);
  swap(trans_mode_, other->trans_mode_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string IMFileTransferRsp::GetTypeName() const {
  return "IM.Server.IMFileTransferRsp";
}


// ===================================================================

void IMFileServerIPReq::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMFileServerIPReq::IMFileServerIPReq()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_IM_2eServer_2eproto::scc_info_IMFileServerIPReq.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMFileServerIPReq)
}
IMFileServerIPReq::IMFileServerIPReq(const IMFileServerIPReq& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMFileServerIPReq)
}

void IMFileServerIPReq::SharedCtor() {
}

IMFileServerIPReq::~IMFileServerIPReq() {
  // @@protoc_insertion_point(destructor:IM.Server.IMFileServerIPReq)
  SharedDtor();
}

void IMFileServerIPReq::SharedDtor() {
}

void IMFileServerIPReq::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IMFileServerIPReq& IMFileServerIPReq::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_IM_2eServer_2eproto::scc_info_IMFileServerIPReq.base);
  return *internal_default_instance();
}


void IMFileServerIPReq::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMFileServerIPReq)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool IMFileServerIPReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMFileServerIPReq)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMFileServerIPReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMFileServerIPReq)
  return false;
#undef DO_
}

void IMFileServerIPReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMFileServerIPReq)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMFileServerIPReq)
}

size_t IMFileServerIPReq::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMFileServerIPReq)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMFileServerIPReq::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileServerIPReq*>(&from));
}

void IMFileServerIPReq::MergeFrom(const IMFileServerIPReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMFileServerIPReq)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void IMFileServerIPReq::CopyFrom(const IMFileServerIPReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMFileServerIPReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileServerIPReq::IsInitialized() const {
  return true;
}

void IMFileServerIPReq::Swap(IMFileServerIPReq* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMFileServerIPReq::InternalSwap(IMFileServerIPReq* other) {
  using std::swap;
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string IMFileServerIPReq::GetTypeName() const {
  return "IM.Server.IMFileServerIPReq";
}


// ===================================================================

void IMFileServerIPRsp::InitAsDefaultInstance() {
}
void IMFileServerIPRsp::clear_ip_addr_list() {
  ip_addr_list_.Clear();
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IMFileServerIPRsp::kIpAddrListFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IMFileServerIPRsp::IMFileServerIPRsp()
  : ::google::protobuf::MessageLite(), _internal_metadata_(NULL) {
  ::google::protobuf::internal::InitSCC(
      &protobuf_IM_2eServer_2eproto::scc_info_IMFileServerIPRsp.base);
  SharedCtor();
  // @@protoc_insertion_point(constructor:IM.Server.IMFileServerIPRsp)
}
IMFileServerIPRsp::IMFileServerIPRsp(const IMFileServerIPRsp& from)
  : ::google::protobuf::MessageLite(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      ip_addr_list_(from.ip_addr_list_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:IM.Server.IMFileServerIPRsp)
}

void IMFileServerIPRsp::SharedCtor() {
}

IMFileServerIPRsp::~IMFileServerIPRsp() {
  // @@protoc_insertion_point(destructor:IM.Server.IMFileServerIPRsp)
  SharedDtor();
}

void IMFileServerIPRsp::SharedDtor() {
}

void IMFileServerIPRsp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IMFileServerIPRsp& IMFileServerIPRsp::default_instance() {
  ::google::protobuf::internal::InitSCC(&protobuf_IM_2eServer_2eproto::scc_info_IMFileServerIPRsp.base);
  return *internal_default_instance();
}


void IMFileServerIPRsp::Clear() {
// @@protoc_insertion_point(message_clear_start:IM.Server.IMFileServerIPRsp)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ip_addr_list_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool IMFileServerIPRsp::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::internal::LiteUnknownFieldSetter unknown_fields_setter(
      &_internal_metadata_);
  ::google::protobuf::io::StringOutputStream unknown_fields_output(
      unknown_fields_setter.buffer());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_output, false);
  // @@protoc_insertion_point(parse_start:IM.Server.IMFileServerIPRsp)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .IM.BaseDefine.IpAddr ip_addr_list = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_ip_addr_list()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:IM.Server.IMFileServerIPRsp)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:IM.Server.IMFileServerIPRsp)
  return false;
#undef DO_
}

void IMFileServerIPRsp::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:IM.Server.IMFileServerIPRsp)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->ip_addr_list_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1,
      this->ip_addr_list(static_cast<int>(i)),
      output);
  }

  output->WriteRaw(_internal_metadata_.unknown_fields().data(),
                   static_cast<int>(_internal_metadata_.unknown_fields().size()));
  // @@protoc_insertion_point(serialize_end:IM.Server.IMFileServerIPRsp)
}

size_t IMFileServerIPRsp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IM.Server.IMFileServerIPRsp)
  size_t total_size = 0;

  total_size += _internal_metadata_.unknown_fields().size();

  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->ip_addr_list_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->ip_addr_list(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMFileServerIPRsp::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const IMFileServerIPRsp*>(&from));
}

void IMFileServerIPRsp::MergeFrom(const IMFileServerIPRsp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IM.Server.IMFileServerIPRsp)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  ip_addr_list_.MergeFrom(from.ip_addr_list_);
}

void IMFileServerIPRsp::CopyFrom(const IMFileServerIPRsp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IM.Server.IMFileServerIPRsp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMFileServerIPRsp::IsInitialized() const {
  if (!::google::protobuf::internal::AllAreInitialized(this->ip_addr_list())) return false;
  return true;
}

void IMFileServerIPRsp::Swap(IMFileServerIPRsp* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IMFileServerIPRsp::InternalSwap(IMFileServerIPRsp* other) {
  using std::swap;
  CastToBase(&ip_addr_list_)->InternalSwap(CastToBase(&other->ip_addr_list_));
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
}

::std::string IMFileServerIPRsp::GetTypeName() const {
  return "IM.Server.IMFileServerIPRsp";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace Server
}  // namespace IM
namespace google {
namespace protobuf {
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::IM::Server::IMStopReceivePacket* Arena::CreateMaybeMessage< ::IM::Server::IMStopReceivePacket >(Arena* arena) {
  return Arena::CreateInternal< ::IM::Server::IMStopReceivePacket >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::IM::Server::IMValidateReq* Arena::CreateMaybeMessage< ::IM::Server::IMValidateReq >(Arena* arena) {
  return Arena::CreateInternal< ::IM::Server::IMValidateReq >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::IM::Server::IMValidateRsp* Arena::CreateMaybeMessage< ::IM::Server::IMValidateRsp >(Arena* arena) {
  return Arena::CreateInternal< ::IM::Server::IMValidateRsp >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::IM::Server::IMGetDeviceTokenReq* Arena::CreateMaybeMessage< ::IM::Server::IMGetDeviceTokenReq >(Arena* arena) {
  return Arena::CreateInternal< ::IM::Server::IMGetDeviceTokenReq >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::IM::Server::IMGetDeviceTokenRsp* Arena::CreateMaybeMessage< ::IM::Server::IMGetDeviceTokenRsp >(Arena* arena) {
  return Arena::CreateInternal< ::IM::Server::IMGetDeviceTokenRsp >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::IM::Server::IMRoleSet* Arena::CreateMaybeMessage< ::IM::Server::IMRoleSet >(Arena* arena) {
  return Arena::CreateInternal< ::IM::Server::IMRoleSet >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::IM::Server::IMOnlineUserInfo* Arena::CreateMaybeMessage< ::IM::Server::IMOnlineUserInfo >(Arena* arena) {
  return Arena::CreateInternal< ::IM::Server::IMOnlineUserInfo >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::IM::Server::IMMsgServInfo* Arena::CreateMaybeMessage< ::IM::Server::IMMsgServInfo >(Arena* arena) {
  return Arena::CreateInternal< ::IM::Server::IMMsgServInfo >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::IM::Server::IMUserStatusUpdate* Arena::CreateMaybeMessage< ::IM::Server::IMUserStatusUpdate >(Arena* arena) {
  return Arena::CreateInternal< ::IM::Server::IMUserStatusUpdate >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::IM::Server::IMUserCntUpdate* Arena::CreateMaybeMessage< ::IM::Server::IMUserCntUpdate >(Arena* arena) {
  return Arena::CreateInternal< ::IM::Server::IMUserCntUpdate >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::IM::Server::IMServerKickUser* Arena::CreateMaybeMessage< ::IM::Server::IMServerKickUser >(Arena* arena) {
  return Arena::CreateInternal< ::IM::Server::IMServerKickUser >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::IM::Server::IMServerPCLoginStatusNotify* Arena::CreateMaybeMessage< ::IM::Server::IMServerPCLoginStatusNotify >(Arena* arena) {
  return Arena::CreateInternal< ::IM::Server::IMServerPCLoginStatusNotify >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::IM::Server::IMPushToUserReq* Arena::CreateMaybeMessage< ::IM::Server::IMPushToUserReq >(Arena* arena) {
  return Arena::CreateInternal< ::IM::Server::IMPushToUserReq >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::IM::Server::IMPushToUserRsp* Arena::CreateMaybeMessage< ::IM::Server::IMPushToUserRsp >(Arena* arena) {
  return Arena::CreateInternal< ::IM::Server::IMPushToUserRsp >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::IM::Server::IMGroupGetShieldReq* Arena::CreateMaybeMessage< ::IM::Server::IMGroupGetShieldReq >(Arena* arena) {
  return Arena::CreateInternal< ::IM::Server::IMGroupGetShieldReq >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::IM::Server::IMGroupGetShieldRsp* Arena::CreateMaybeMessage< ::IM::Server::IMGroupGetShieldRsp >(Arena* arena) {
  return Arena::CreateInternal< ::IM::Server::IMGroupGetShieldRsp >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::IM::Server::IMFileTransferReq* Arena::CreateMaybeMessage< ::IM::Server::IMFileTransferReq >(Arena* arena) {
  return Arena::CreateInternal< ::IM::Server::IMFileTransferReq >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::IM::Server::IMFileTransferRsp* Arena::CreateMaybeMessage< ::IM::Server::IMFileTransferRsp >(Arena* arena) {
  return Arena::CreateInternal< ::IM::Server::IMFileTransferRsp >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::IM::Server::IMFileServerIPReq* Arena::CreateMaybeMessage< ::IM::Server::IMFileServerIPReq >(Arena* arena) {
  return Arena::CreateInternal< ::IM::Server::IMFileServerIPReq >(arena);
}
template<> GOOGLE_PROTOBUF_ATTRIBUTE_NOINLINE ::IM::Server::IMFileServerIPRsp* Arena::CreateMaybeMessage< ::IM::Server::IMFileServerIPRsp >(Arena* arena) {
  return Arena::CreateInternal< ::IM::Server::IMFileServerIPRsp >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
