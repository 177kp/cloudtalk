// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.File.proto

#ifndef PROTOBUF_INCLUDED_IM_2eFile_2eproto
#define PROTOBUF_INCLUDED_IM_2eFile_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "IM.BaseDefine.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_IM_2eFile_2eproto 

namespace protobuf_IM_2eFile_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
}  // namespace protobuf_IM_2eFile_2eproto
namespace IM {
namespace File {
class IMFileAddOfflineReq;
class IMFileAddOfflineReqDefaultTypeInternal;
extern IMFileAddOfflineReqDefaultTypeInternal _IMFileAddOfflineReq_default_instance_;
class IMFileDelOfflineReq;
class IMFileDelOfflineReqDefaultTypeInternal;
extern IMFileDelOfflineReqDefaultTypeInternal _IMFileDelOfflineReq_default_instance_;
class IMFileHasOfflineReq;
class IMFileHasOfflineReqDefaultTypeInternal;
extern IMFileHasOfflineReqDefaultTypeInternal _IMFileHasOfflineReq_default_instance_;
class IMFileHasOfflineRsp;
class IMFileHasOfflineRspDefaultTypeInternal;
extern IMFileHasOfflineRspDefaultTypeInternal _IMFileHasOfflineRsp_default_instance_;
class IMFileLoginReq;
class IMFileLoginReqDefaultTypeInternal;
extern IMFileLoginReqDefaultTypeInternal _IMFileLoginReq_default_instance_;
class IMFileLoginRsp;
class IMFileLoginRspDefaultTypeInternal;
extern IMFileLoginRspDefaultTypeInternal _IMFileLoginRsp_default_instance_;
class IMFileNotify;
class IMFileNotifyDefaultTypeInternal;
extern IMFileNotifyDefaultTypeInternal _IMFileNotify_default_instance_;
class IMFilePullDataReq;
class IMFilePullDataReqDefaultTypeInternal;
extern IMFilePullDataReqDefaultTypeInternal _IMFilePullDataReq_default_instance_;
class IMFilePullDataRsp;
class IMFilePullDataRspDefaultTypeInternal;
extern IMFilePullDataRspDefaultTypeInternal _IMFilePullDataRsp_default_instance_;
class IMFileReq;
class IMFileReqDefaultTypeInternal;
extern IMFileReqDefaultTypeInternal _IMFileReq_default_instance_;
class IMFileRsp;
class IMFileRspDefaultTypeInternal;
extern IMFileRspDefaultTypeInternal _IMFileRsp_default_instance_;
class IMFileState;
class IMFileStateDefaultTypeInternal;
extern IMFileStateDefaultTypeInternal _IMFileState_default_instance_;
}  // namespace File
}  // namespace IM
namespace google {
namespace protobuf {
template<> ::IM::File::IMFileAddOfflineReq* Arena::CreateMaybeMessage<::IM::File::IMFileAddOfflineReq>(Arena*);
template<> ::IM::File::IMFileDelOfflineReq* Arena::CreateMaybeMessage<::IM::File::IMFileDelOfflineReq>(Arena*);
template<> ::IM::File::IMFileHasOfflineReq* Arena::CreateMaybeMessage<::IM::File::IMFileHasOfflineReq>(Arena*);
template<> ::IM::File::IMFileHasOfflineRsp* Arena::CreateMaybeMessage<::IM::File::IMFileHasOfflineRsp>(Arena*);
template<> ::IM::File::IMFileLoginReq* Arena::CreateMaybeMessage<::IM::File::IMFileLoginReq>(Arena*);
template<> ::IM::File::IMFileLoginRsp* Arena::CreateMaybeMessage<::IM::File::IMFileLoginRsp>(Arena*);
template<> ::IM::File::IMFileNotify* Arena::CreateMaybeMessage<::IM::File::IMFileNotify>(Arena*);
template<> ::IM::File::IMFilePullDataReq* Arena::CreateMaybeMessage<::IM::File::IMFilePullDataReq>(Arena*);
template<> ::IM::File::IMFilePullDataRsp* Arena::CreateMaybeMessage<::IM::File::IMFilePullDataRsp>(Arena*);
template<> ::IM::File::IMFileReq* Arena::CreateMaybeMessage<::IM::File::IMFileReq>(Arena*);
template<> ::IM::File::IMFileRsp* Arena::CreateMaybeMessage<::IM::File::IMFileRsp>(Arena*);
template<> ::IM::File::IMFileState* Arena::CreateMaybeMessage<::IM::File::IMFileState>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace IM {
namespace File {

// ===================================================================

class IMFileLoginReq : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileLoginReq) */ {
 public:
  IMFileLoginReq();
  virtual ~IMFileLoginReq();

  IMFileLoginReq(const IMFileLoginReq& from);

  inline IMFileLoginReq& operator=(const IMFileLoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMFileLoginReq(IMFileLoginReq&& from) noexcept
    : IMFileLoginReq() {
    *this = ::std::move(from);
  }

  inline IMFileLoginReq& operator=(IMFileLoginReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IMFileLoginReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMFileLoginReq* internal_default_instance() {
    return reinterpret_cast<const IMFileLoginReq*>(
               &_IMFileLoginReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(IMFileLoginReq* other);
  friend void swap(IMFileLoginReq& a, IMFileLoginReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMFileLoginReq* New() const final {
    return CreateMaybeMessage<IMFileLoginReq>(NULL);
  }

  IMFileLoginReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IMFileLoginReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const IMFileLoginReq& from);
  void MergeFrom(const IMFileLoginReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileLoginReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string task_id = 2;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  #if LANG_CXX11
  void set_task_id(::std::string&& value);
  #endif
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // required uint32 user_id = 1;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::uint32 user_id() const;
  void set_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.ClientFileRole file_role = 3;
  bool has_file_role() const;
  void clear_file_role();
  static const int kFileRoleFieldNumber = 3;
  ::IM::BaseDefine::ClientFileRole file_role() const;
  void set_file_role(::IM::BaseDefine::ClientFileRole value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileLoginReq)
 private:
  void set_has_user_id();
  void clear_has_user_id();
  void set_has_task_id();
  void clear_has_task_id();
  void set_has_file_role();
  void clear_has_file_role();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  ::google::protobuf::uint32 user_id_;
  int file_role_;
  friend struct ::protobuf_IM_2eFile_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IMFileLoginRsp : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileLoginRsp) */ {
 public:
  IMFileLoginRsp();
  virtual ~IMFileLoginRsp();

  IMFileLoginRsp(const IMFileLoginRsp& from);

  inline IMFileLoginRsp& operator=(const IMFileLoginRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMFileLoginRsp(IMFileLoginRsp&& from) noexcept
    : IMFileLoginRsp() {
    *this = ::std::move(from);
  }

  inline IMFileLoginRsp& operator=(IMFileLoginRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IMFileLoginRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMFileLoginRsp* internal_default_instance() {
    return reinterpret_cast<const IMFileLoginRsp*>(
               &_IMFileLoginRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(IMFileLoginRsp* other);
  friend void swap(IMFileLoginRsp& a, IMFileLoginRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMFileLoginRsp* New() const final {
    return CreateMaybeMessage<IMFileLoginRsp>(NULL);
  }

  IMFileLoginRsp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IMFileLoginRsp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const IMFileLoginRsp& from);
  void MergeFrom(const IMFileLoginRsp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileLoginRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string task_id = 2;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  #if LANG_CXX11
  void set_task_id(::std::string&& value);
  #endif
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // required uint32 result_code = 1;
  bool has_result_code() const;
  void clear_result_code();
  static const int kResultCodeFieldNumber = 1;
  ::google::protobuf::uint32 result_code() const;
  void set_result_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileLoginRsp)
 private:
  void set_has_result_code();
  void clear_has_result_code();
  void set_has_task_id();
  void clear_has_task_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  ::google::protobuf::uint32 result_code_;
  friend struct ::protobuf_IM_2eFile_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IMFileState : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileState) */ {
 public:
  IMFileState();
  virtual ~IMFileState();

  IMFileState(const IMFileState& from);

  inline IMFileState& operator=(const IMFileState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMFileState(IMFileState&& from) noexcept
    : IMFileState() {
    *this = ::std::move(from);
  }

  inline IMFileState& operator=(IMFileState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IMFileState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMFileState* internal_default_instance() {
    return reinterpret_cast<const IMFileState*>(
               &_IMFileState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(IMFileState* other);
  friend void swap(IMFileState& a, IMFileState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMFileState* New() const final {
    return CreateMaybeMessage<IMFileState>(NULL);
  }

  IMFileState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IMFileState>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const IMFileState& from);
  void MergeFrom(const IMFileState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string task_id = 2;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  #if LANG_CXX11
  void set_task_id(::std::string&& value);
  #endif
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // required .IM.BaseDefine.ClientFileState state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  ::IM::BaseDefine::ClientFileState state() const;
  void set_state(::IM::BaseDefine::ClientFileState value);

  // required uint32 user_id = 3;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 3;
  ::google::protobuf::uint32 user_id() const;
  void set_user_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileState)
 private:
  void set_has_state();
  void clear_has_state();
  void set_has_task_id();
  void clear_has_task_id();
  void set_has_user_id();
  void clear_has_user_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  int state_;
  ::google::protobuf::uint32 user_id_;
  friend struct ::protobuf_IM_2eFile_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IMFilePullDataReq : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFilePullDataReq) */ {
 public:
  IMFilePullDataReq();
  virtual ~IMFilePullDataReq();

  IMFilePullDataReq(const IMFilePullDataReq& from);

  inline IMFilePullDataReq& operator=(const IMFilePullDataReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMFilePullDataReq(IMFilePullDataReq&& from) noexcept
    : IMFilePullDataReq() {
    *this = ::std::move(from);
  }

  inline IMFilePullDataReq& operator=(IMFilePullDataReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IMFilePullDataReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMFilePullDataReq* internal_default_instance() {
    return reinterpret_cast<const IMFilePullDataReq*>(
               &_IMFilePullDataReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(IMFilePullDataReq* other);
  friend void swap(IMFilePullDataReq& a, IMFilePullDataReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMFilePullDataReq* New() const final {
    return CreateMaybeMessage<IMFilePullDataReq>(NULL);
  }

  IMFilePullDataReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IMFilePullDataReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const IMFilePullDataReq& from);
  void MergeFrom(const IMFilePullDataReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFilePullDataReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string task_id = 1;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  #if LANG_CXX11
  void set_task_id(::std::string&& value);
  #endif
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // required uint32 user_id = 2;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  ::google::protobuf::uint32 user_id() const;
  void set_user_id(::google::protobuf::uint32 value);

  // required uint32 offset = 4;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 4;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // required uint32 data_size = 5;
  bool has_data_size() const;
  void clear_data_size();
  static const int kDataSizeFieldNumber = 5;
  ::google::protobuf::uint32 data_size() const;
  void set_data_size(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.TransferFileType trans_mode = 3;
  bool has_trans_mode() const;
  void clear_trans_mode();
  static const int kTransModeFieldNumber = 3;
  ::IM::BaseDefine::TransferFileType trans_mode() const;
  void set_trans_mode(::IM::BaseDefine::TransferFileType value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFilePullDataReq)
 private:
  void set_has_task_id();
  void clear_has_task_id();
  void set_has_user_id();
  void clear_has_user_id();
  void set_has_trans_mode();
  void clear_has_trans_mode();
  void set_has_offset();
  void clear_has_offset();
  void set_has_data_size();
  void clear_has_data_size();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 offset_;
  ::google::protobuf::uint32 data_size_;
  int trans_mode_;
  friend struct ::protobuf_IM_2eFile_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IMFilePullDataRsp : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFilePullDataRsp) */ {
 public:
  IMFilePullDataRsp();
  virtual ~IMFilePullDataRsp();

  IMFilePullDataRsp(const IMFilePullDataRsp& from);

  inline IMFilePullDataRsp& operator=(const IMFilePullDataRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMFilePullDataRsp(IMFilePullDataRsp&& from) noexcept
    : IMFilePullDataRsp() {
    *this = ::std::move(from);
  }

  inline IMFilePullDataRsp& operator=(IMFilePullDataRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IMFilePullDataRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMFilePullDataRsp* internal_default_instance() {
    return reinterpret_cast<const IMFilePullDataRsp*>(
               &_IMFilePullDataRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(IMFilePullDataRsp* other);
  friend void swap(IMFilePullDataRsp& a, IMFilePullDataRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMFilePullDataRsp* New() const final {
    return CreateMaybeMessage<IMFilePullDataRsp>(NULL);
  }

  IMFilePullDataRsp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IMFilePullDataRsp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const IMFilePullDataRsp& from);
  void MergeFrom(const IMFilePullDataRsp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFilePullDataRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string task_id = 2;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  #if LANG_CXX11
  void set_task_id(::std::string&& value);
  #endif
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // required bytes file_data = 5;
  bool has_file_data() const;
  void clear_file_data();
  static const int kFileDataFieldNumber = 5;
  const ::std::string& file_data() const;
  void set_file_data(const ::std::string& value);
  #if LANG_CXX11
  void set_file_data(::std::string&& value);
  #endif
  void set_file_data(const char* value);
  void set_file_data(const void* value, size_t size);
  ::std::string* mutable_file_data();
  ::std::string* release_file_data();
  void set_allocated_file_data(::std::string* file_data);

  // required uint32 result_code = 1;
  bool has_result_code() const;
  void clear_result_code();
  static const int kResultCodeFieldNumber = 1;
  ::google::protobuf::uint32 result_code() const;
  void set_result_code(::google::protobuf::uint32 value);

  // required uint32 user_id = 3;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 3;
  ::google::protobuf::uint32 user_id() const;
  void set_user_id(::google::protobuf::uint32 value);

  // required uint32 offset = 4;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 4;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFilePullDataRsp)
 private:
  void set_has_result_code();
  void clear_has_result_code();
  void set_has_task_id();
  void clear_has_task_id();
  void set_has_user_id();
  void clear_has_user_id();
  void set_has_offset();
  void clear_has_offset();
  void set_has_file_data();
  void clear_has_file_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  ::google::protobuf::internal::ArenaStringPtr file_data_;
  ::google::protobuf::uint32 result_code_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 offset_;
  friend struct ::protobuf_IM_2eFile_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IMFileReq : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileReq) */ {
 public:
  IMFileReq();
  virtual ~IMFileReq();

  IMFileReq(const IMFileReq& from);

  inline IMFileReq& operator=(const IMFileReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMFileReq(IMFileReq&& from) noexcept
    : IMFileReq() {
    *this = ::std::move(from);
  }

  inline IMFileReq& operator=(IMFileReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IMFileReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMFileReq* internal_default_instance() {
    return reinterpret_cast<const IMFileReq*>(
               &_IMFileReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(IMFileReq* other);
  friend void swap(IMFileReq& a, IMFileReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMFileReq* New() const final {
    return CreateMaybeMessage<IMFileReq>(NULL);
  }

  IMFileReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IMFileReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const IMFileReq& from);
  void MergeFrom(const IMFileReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_name = 3;
  bool has_file_name() const;
  void clear_file_name();
  static const int kFileNameFieldNumber = 3;
  const ::std::string& file_name() const;
  void set_file_name(const ::std::string& value);
  #if LANG_CXX11
  void set_file_name(::std::string&& value);
  #endif
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  ::std::string* mutable_file_name();
  ::std::string* release_file_name();
  void set_allocated_file_name(::std::string* file_name);

  // required uint32 from_user_id = 1;
  bool has_from_user_id() const;
  void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 1;
  ::google::protobuf::uint32 from_user_id() const;
  void set_from_user_id(::google::protobuf::uint32 value);

  // required uint32 to_user_id = 2;
  bool has_to_user_id() const;
  void clear_to_user_id();
  static const int kToUserIdFieldNumber = 2;
  ::google::protobuf::uint32 to_user_id() const;
  void set_to_user_id(::google::protobuf::uint32 value);

  // required uint32 file_size = 4;
  bool has_file_size() const;
  void clear_file_size();
  static const int kFileSizeFieldNumber = 4;
  ::google::protobuf::uint32 file_size() const;
  void set_file_size(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.TransferFileType trans_mode = 5;
  bool has_trans_mode() const;
  void clear_trans_mode();
  static const int kTransModeFieldNumber = 5;
  ::IM::BaseDefine::TransferFileType trans_mode() const;
  void set_trans_mode(::IM::BaseDefine::TransferFileType value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileReq)
 private:
  void set_has_from_user_id();
  void clear_has_from_user_id();
  void set_has_to_user_id();
  void clear_has_to_user_id();
  void set_has_file_name();
  void clear_has_file_name();
  void set_has_file_size();
  void clear_has_file_size();
  void set_has_trans_mode();
  void clear_has_trans_mode();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  ::google::protobuf::uint32 from_user_id_;
  ::google::protobuf::uint32 to_user_id_;
  ::google::protobuf::uint32 file_size_;
  int trans_mode_;
  friend struct ::protobuf_IM_2eFile_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IMFileRsp : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileRsp) */ {
 public:
  IMFileRsp();
  virtual ~IMFileRsp();

  IMFileRsp(const IMFileRsp& from);

  inline IMFileRsp& operator=(const IMFileRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMFileRsp(IMFileRsp&& from) noexcept
    : IMFileRsp() {
    *this = ::std::move(from);
  }

  inline IMFileRsp& operator=(IMFileRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IMFileRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMFileRsp* internal_default_instance() {
    return reinterpret_cast<const IMFileRsp*>(
               &_IMFileRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(IMFileRsp* other);
  friend void swap(IMFileRsp& a, IMFileRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMFileRsp* New() const final {
    return CreateMaybeMessage<IMFileRsp>(NULL);
  }

  IMFileRsp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IMFileRsp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const IMFileRsp& from);
  void MergeFrom(const IMFileRsp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
  int ip_addr_list_size() const;
  void clear_ip_addr_list();
  static const int kIpAddrListFieldNumber = 6;
  ::IM::BaseDefine::IpAddr* mutable_ip_addr_list(int index);
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
      mutable_ip_addr_list();
  const ::IM::BaseDefine::IpAddr& ip_addr_list(int index) const;
  ::IM::BaseDefine::IpAddr* add_ip_addr_list();
  const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
      ip_addr_list() const;

  // required string file_name = 4;
  bool has_file_name() const;
  void clear_file_name();
  static const int kFileNameFieldNumber = 4;
  const ::std::string& file_name() const;
  void set_file_name(const ::std::string& value);
  #if LANG_CXX11
  void set_file_name(::std::string&& value);
  #endif
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  ::std::string* mutable_file_name();
  ::std::string* release_file_name();
  void set_allocated_file_name(::std::string* file_name);

  // required string task_id = 5;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 5;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  #if LANG_CXX11
  void set_task_id(::std::string&& value);
  #endif
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // required uint32 result_code = 1;
  bool has_result_code() const;
  void clear_result_code();
  static const int kResultCodeFieldNumber = 1;
  ::google::protobuf::uint32 result_code() const;
  void set_result_code(::google::protobuf::uint32 value);

  // required uint32 from_user_id = 2;
  bool has_from_user_id() const;
  void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 2;
  ::google::protobuf::uint32 from_user_id() const;
  void set_from_user_id(::google::protobuf::uint32 value);

  // required uint32 to_user_id = 3;
  bool has_to_user_id() const;
  void clear_to_user_id();
  static const int kToUserIdFieldNumber = 3;
  ::google::protobuf::uint32 to_user_id() const;
  void set_to_user_id(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.TransferFileType trans_mode = 7;
  bool has_trans_mode() const;
  void clear_trans_mode();
  static const int kTransModeFieldNumber = 7;
  ::IM::BaseDefine::TransferFileType trans_mode() const;
  void set_trans_mode(::IM::BaseDefine::TransferFileType value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileRsp)
 private:
  void set_has_result_code();
  void clear_has_result_code();
  void set_has_from_user_id();
  void clear_has_from_user_id();
  void set_has_to_user_id();
  void clear_has_to_user_id();
  void set_has_file_name();
  void clear_has_file_name();
  void set_has_task_id();
  void clear_has_task_id();
  void set_has_trans_mode();
  void clear_has_trans_mode();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr > ip_addr_list_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  ::google::protobuf::uint32 result_code_;
  ::google::protobuf::uint32 from_user_id_;
  ::google::protobuf::uint32 to_user_id_;
  int trans_mode_;
  friend struct ::protobuf_IM_2eFile_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IMFileNotify : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileNotify) */ {
 public:
  IMFileNotify();
  virtual ~IMFileNotify();

  IMFileNotify(const IMFileNotify& from);

  inline IMFileNotify& operator=(const IMFileNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMFileNotify(IMFileNotify&& from) noexcept
    : IMFileNotify() {
    *this = ::std::move(from);
  }

  inline IMFileNotify& operator=(IMFileNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IMFileNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMFileNotify* internal_default_instance() {
    return reinterpret_cast<const IMFileNotify*>(
               &_IMFileNotify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(IMFileNotify* other);
  friend void swap(IMFileNotify& a, IMFileNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMFileNotify* New() const final {
    return CreateMaybeMessage<IMFileNotify>(NULL);
  }

  IMFileNotify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IMFileNotify>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const IMFileNotify& from);
  void MergeFrom(const IMFileNotify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileNotify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
  int ip_addr_list_size() const;
  void clear_ip_addr_list();
  static const int kIpAddrListFieldNumber = 6;
  ::IM::BaseDefine::IpAddr* mutable_ip_addr_list(int index);
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
      mutable_ip_addr_list();
  const ::IM::BaseDefine::IpAddr& ip_addr_list(int index) const;
  ::IM::BaseDefine::IpAddr* add_ip_addr_list();
  const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
      ip_addr_list() const;

  // required string file_name = 3;
  bool has_file_name() const;
  void clear_file_name();
  static const int kFileNameFieldNumber = 3;
  const ::std::string& file_name() const;
  void set_file_name(const ::std::string& value);
  #if LANG_CXX11
  void set_file_name(::std::string&& value);
  #endif
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  ::std::string* mutable_file_name();
  ::std::string* release_file_name();
  void set_allocated_file_name(::std::string* file_name);

  // required string task_id = 5;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 5;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  #if LANG_CXX11
  void set_task_id(::std::string&& value);
  #endif
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // required uint32 from_user_id = 1;
  bool has_from_user_id() const;
  void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 1;
  ::google::protobuf::uint32 from_user_id() const;
  void set_from_user_id(::google::protobuf::uint32 value);

  // required uint32 to_user_id = 2;
  bool has_to_user_id() const;
  void clear_to_user_id();
  static const int kToUserIdFieldNumber = 2;
  ::google::protobuf::uint32 to_user_id() const;
  void set_to_user_id(::google::protobuf::uint32 value);

  // required uint32 file_size = 4;
  bool has_file_size() const;
  void clear_file_size();
  static const int kFileSizeFieldNumber = 4;
  ::google::protobuf::uint32 file_size() const;
  void set_file_size(::google::protobuf::uint32 value);

  // required uint32 offline_ready = 8;
  bool has_offline_ready() const;
  void clear_offline_ready();
  static const int kOfflineReadyFieldNumber = 8;
  ::google::protobuf::uint32 offline_ready() const;
  void set_offline_ready(::google::protobuf::uint32 value);

  // required .IM.BaseDefine.TransferFileType trans_mode = 7;
  bool has_trans_mode() const;
  void clear_trans_mode();
  static const int kTransModeFieldNumber = 7;
  ::IM::BaseDefine::TransferFileType trans_mode() const;
  void set_trans_mode(::IM::BaseDefine::TransferFileType value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileNotify)
 private:
  void set_has_from_user_id();
  void clear_has_from_user_id();
  void set_has_to_user_id();
  void clear_has_to_user_id();
  void set_has_file_name();
  void clear_has_file_name();
  void set_has_file_size();
  void clear_has_file_size();
  void set_has_task_id();
  void clear_has_task_id();
  void set_has_trans_mode();
  void clear_has_trans_mode();
  void set_has_offline_ready();
  void clear_has_offline_ready();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr > ip_addr_list_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  ::google::protobuf::uint32 from_user_id_;
  ::google::protobuf::uint32 to_user_id_;
  ::google::protobuf::uint32 file_size_;
  ::google::protobuf::uint32 offline_ready_;
  int trans_mode_;
  friend struct ::protobuf_IM_2eFile_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IMFileHasOfflineReq : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileHasOfflineReq) */ {
 public:
  IMFileHasOfflineReq();
  virtual ~IMFileHasOfflineReq();

  IMFileHasOfflineReq(const IMFileHasOfflineReq& from);

  inline IMFileHasOfflineReq& operator=(const IMFileHasOfflineReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMFileHasOfflineReq(IMFileHasOfflineReq&& from) noexcept
    : IMFileHasOfflineReq() {
    *this = ::std::move(from);
  }

  inline IMFileHasOfflineReq& operator=(IMFileHasOfflineReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IMFileHasOfflineReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMFileHasOfflineReq* internal_default_instance() {
    return reinterpret_cast<const IMFileHasOfflineReq*>(
               &_IMFileHasOfflineReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(IMFileHasOfflineReq* other);
  friend void swap(IMFileHasOfflineReq& a, IMFileHasOfflineReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMFileHasOfflineReq* New() const final {
    return CreateMaybeMessage<IMFileHasOfflineReq>(NULL);
  }

  IMFileHasOfflineReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IMFileHasOfflineReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const IMFileHasOfflineReq& from);
  void MergeFrom(const IMFileHasOfflineReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileHasOfflineReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  const ::std::string& attach_data() const;
  void set_attach_data(const ::std::string& value);
  #if LANG_CXX11
  void set_attach_data(::std::string&& value);
  #endif
  void set_attach_data(const char* value);
  void set_attach_data(const void* value, size_t size);
  ::std::string* mutable_attach_data();
  ::std::string* release_attach_data();
  void set_allocated_attach_data(::std::string* attach_data);

  // required uint32 user_id = 1;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::uint32 user_id() const;
  void set_user_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileHasOfflineReq)
 private:
  void set_has_user_id();
  void clear_has_user_id();
  void set_has_attach_data();
  void clear_has_attach_data();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr attach_data_;
  ::google::protobuf::uint32 user_id_;
  friend struct ::protobuf_IM_2eFile_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IMFileHasOfflineRsp : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileHasOfflineRsp) */ {
 public:
  IMFileHasOfflineRsp();
  virtual ~IMFileHasOfflineRsp();

  IMFileHasOfflineRsp(const IMFileHasOfflineRsp& from);

  inline IMFileHasOfflineRsp& operator=(const IMFileHasOfflineRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMFileHasOfflineRsp(IMFileHasOfflineRsp&& from) noexcept
    : IMFileHasOfflineRsp() {
    *this = ::std::move(from);
  }

  inline IMFileHasOfflineRsp& operator=(IMFileHasOfflineRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IMFileHasOfflineRsp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMFileHasOfflineRsp* internal_default_instance() {
    return reinterpret_cast<const IMFileHasOfflineRsp*>(
               &_IMFileHasOfflineRsp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(IMFileHasOfflineRsp* other);
  friend void swap(IMFileHasOfflineRsp& a, IMFileHasOfflineRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMFileHasOfflineRsp* New() const final {
    return CreateMaybeMessage<IMFileHasOfflineRsp>(NULL);
  }

  IMFileHasOfflineRsp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IMFileHasOfflineRsp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const IMFileHasOfflineRsp& from);
  void MergeFrom(const IMFileHasOfflineRsp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileHasOfflineRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .IM.BaseDefine.OfflineFileInfo offline_file_list = 2;
  int offline_file_list_size() const;
  void clear_offline_file_list();
  static const int kOfflineFileListFieldNumber = 2;
  ::IM::BaseDefine::OfflineFileInfo* mutable_offline_file_list(int index);
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo >*
      mutable_offline_file_list();
  const ::IM::BaseDefine::OfflineFileInfo& offline_file_list(int index) const;
  ::IM::BaseDefine::OfflineFileInfo* add_offline_file_list();
  const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo >&
      offline_file_list() const;

  // repeated .IM.BaseDefine.IpAddr ip_addr_list = 3;
  int ip_addr_list_size() const;
  void clear_ip_addr_list();
  static const int kIpAddrListFieldNumber = 3;
  ::IM::BaseDefine::IpAddr* mutable_ip_addr_list(int index);
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
      mutable_ip_addr_list();
  const ::IM::BaseDefine::IpAddr& ip_addr_list(int index) const;
  ::IM::BaseDefine::IpAddr* add_ip_addr_list();
  const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
      ip_addr_list() const;

  // optional bytes attach_data = 20;
  bool has_attach_data() const;
  void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  const ::std::string& attach_data() const;
  void set_attach_data(const ::std::string& value);
  #if LANG_CXX11
  void set_attach_data(::std::string&& value);
  #endif
  void set_attach_data(const char* value);
  void set_attach_data(const void* value, size_t size);
  ::std::string* mutable_attach_data();
  ::std::string* release_attach_data();
  void set_allocated_attach_data(::std::string* attach_data);

  // required uint32 user_id = 1;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::uint32 user_id() const;
  void set_user_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileHasOfflineRsp)
 private:
  void set_has_user_id();
  void clear_has_user_id();
  void set_has_attach_data();
  void clear_has_attach_data();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo > offline_file_list_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr > ip_addr_list_;
  ::google::protobuf::internal::ArenaStringPtr attach_data_;
  ::google::protobuf::uint32 user_id_;
  friend struct ::protobuf_IM_2eFile_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IMFileAddOfflineReq : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileAddOfflineReq) */ {
 public:
  IMFileAddOfflineReq();
  virtual ~IMFileAddOfflineReq();

  IMFileAddOfflineReq(const IMFileAddOfflineReq& from);

  inline IMFileAddOfflineReq& operator=(const IMFileAddOfflineReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMFileAddOfflineReq(IMFileAddOfflineReq&& from) noexcept
    : IMFileAddOfflineReq() {
    *this = ::std::move(from);
  }

  inline IMFileAddOfflineReq& operator=(IMFileAddOfflineReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IMFileAddOfflineReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMFileAddOfflineReq* internal_default_instance() {
    return reinterpret_cast<const IMFileAddOfflineReq*>(
               &_IMFileAddOfflineReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(IMFileAddOfflineReq* other);
  friend void swap(IMFileAddOfflineReq& a, IMFileAddOfflineReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMFileAddOfflineReq* New() const final {
    return CreateMaybeMessage<IMFileAddOfflineReq>(NULL);
  }

  IMFileAddOfflineReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IMFileAddOfflineReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const IMFileAddOfflineReq& from);
  void MergeFrom(const IMFileAddOfflineReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileAddOfflineReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string task_id = 3;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 3;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  #if LANG_CXX11
  void set_task_id(::std::string&& value);
  #endif
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // required string file_name = 4;
  bool has_file_name() const;
  void clear_file_name();
  static const int kFileNameFieldNumber = 4;
  const ::std::string& file_name() const;
  void set_file_name(const ::std::string& value);
  #if LANG_CXX11
  void set_file_name(::std::string&& value);
  #endif
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  ::std::string* mutable_file_name();
  ::std::string* release_file_name();
  void set_allocated_file_name(::std::string* file_name);

  // required uint32 from_user_id = 1;
  bool has_from_user_id() const;
  void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 1;
  ::google::protobuf::uint32 from_user_id() const;
  void set_from_user_id(::google::protobuf::uint32 value);

  // required uint32 to_user_id = 2;
  bool has_to_user_id() const;
  void clear_to_user_id();
  static const int kToUserIdFieldNumber = 2;
  ::google::protobuf::uint32 to_user_id() const;
  void set_to_user_id(::google::protobuf::uint32 value);

  // required uint32 file_size = 5;
  bool has_file_size() const;
  void clear_file_size();
  static const int kFileSizeFieldNumber = 5;
  ::google::protobuf::uint32 file_size() const;
  void set_file_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileAddOfflineReq)
 private:
  void set_has_from_user_id();
  void clear_has_from_user_id();
  void set_has_to_user_id();
  void clear_has_to_user_id();
  void set_has_task_id();
  void clear_has_task_id();
  void set_has_file_name();
  void clear_has_file_name();
  void set_has_file_size();
  void clear_has_file_size();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  ::google::protobuf::uint32 from_user_id_;
  ::google::protobuf::uint32 to_user_id_;
  ::google::protobuf::uint32 file_size_;
  friend struct ::protobuf_IM_2eFile_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IMFileDelOfflineReq : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:IM.File.IMFileDelOfflineReq) */ {
 public:
  IMFileDelOfflineReq();
  virtual ~IMFileDelOfflineReq();

  IMFileDelOfflineReq(const IMFileDelOfflineReq& from);

  inline IMFileDelOfflineReq& operator=(const IMFileDelOfflineReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMFileDelOfflineReq(IMFileDelOfflineReq&& from) noexcept
    : IMFileDelOfflineReq() {
    *this = ::std::move(from);
  }

  inline IMFileDelOfflineReq& operator=(IMFileDelOfflineReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IMFileDelOfflineReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IMFileDelOfflineReq* internal_default_instance() {
    return reinterpret_cast<const IMFileDelOfflineReq*>(
               &_IMFileDelOfflineReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(IMFileDelOfflineReq* other);
  friend void swap(IMFileDelOfflineReq& a, IMFileDelOfflineReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMFileDelOfflineReq* New() const final {
    return CreateMaybeMessage<IMFileDelOfflineReq>(NULL);
  }

  IMFileDelOfflineReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IMFileDelOfflineReq>(arena);
  }
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    final;
  void CopyFrom(const IMFileDelOfflineReq& from);
  void MergeFrom(const IMFileDelOfflineReq& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  void DiscardUnknownFields();
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IMFileDelOfflineReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string task_id = 3;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 3;
  const ::std::string& task_id() const;
  void set_task_id(const ::std::string& value);
  #if LANG_CXX11
  void set_task_id(::std::string&& value);
  #endif
  void set_task_id(const char* value);
  void set_task_id(const char* value, size_t size);
  ::std::string* mutable_task_id();
  ::std::string* release_task_id();
  void set_allocated_task_id(::std::string* task_id);

  // required uint32 from_user_id = 1;
  bool has_from_user_id() const;
  void clear_from_user_id();
  static const int kFromUserIdFieldNumber = 1;
  ::google::protobuf::uint32 from_user_id() const;
  void set_from_user_id(::google::protobuf::uint32 value);

  // required uint32 to_user_id = 2;
  bool has_to_user_id() const;
  void clear_to_user_id();
  static const int kToUserIdFieldNumber = 2;
  ::google::protobuf::uint32 to_user_id() const;
  void set_to_user_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:IM.File.IMFileDelOfflineReq)
 private:
  void set_has_from_user_id();
  void clear_has_from_user_id();
  void set_has_to_user_id();
  void clear_has_to_user_id();
  void set_has_task_id();
  void clear_has_task_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr task_id_;
  ::google::protobuf::uint32 from_user_id_;
  ::google::protobuf::uint32 to_user_id_;
  friend struct ::protobuf_IM_2eFile_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// IMFileLoginReq

// required uint32 user_id = 1;
inline bool IMFileLoginReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileLoginReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileLoginReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileLoginReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMFileLoginReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileLoginReq.user_id)
  return user_id_;
}
inline void IMFileLoginReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileLoginReq.user_id)
}

// required string task_id = 2;
inline bool IMFileLoginReq::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileLoginReq::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileLoginReq::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileLoginReq::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_task_id();
}
inline const ::std::string& IMFileLoginReq::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileLoginReq.task_id)
  return task_id_.GetNoArena();
}
inline void IMFileLoginReq::set_task_id(const ::std::string& value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileLoginReq.task_id)
}
#if LANG_CXX11
inline void IMFileLoginReq::set_task_id(::std::string&& value) {
  set_has_task_id();
  task_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileLoginReq.task_id)
}
#endif
inline void IMFileLoginReq::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileLoginReq.task_id)
}
inline void IMFileLoginReq::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileLoginReq.task_id)
}
inline ::std::string* IMFileLoginReq::mutable_task_id() {
  set_has_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileLoginReq.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileLoginReq::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileLoginReq.task_id)
  if (!has_task_id()) {
    return NULL;
  }
  clear_has_task_id();
  return task_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileLoginReq::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileLoginReq.task_id)
}

// required .IM.BaseDefine.ClientFileRole file_role = 3;
inline bool IMFileLoginReq::has_file_role() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFileLoginReq::set_has_file_role() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFileLoginReq::clear_has_file_role() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFileLoginReq::clear_file_role() {
  file_role_ = 1;
  clear_has_file_role();
}
inline ::IM::BaseDefine::ClientFileRole IMFileLoginReq::file_role() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileLoginReq.file_role)
  return static_cast< ::IM::BaseDefine::ClientFileRole >(file_role_);
}
inline void IMFileLoginReq::set_file_role(::IM::BaseDefine::ClientFileRole value) {
  assert(::IM::BaseDefine::ClientFileRole_IsValid(value));
  set_has_file_role();
  file_role_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileLoginReq.file_role)
}

// -------------------------------------------------------------------

// IMFileLoginRsp

// required uint32 result_code = 1;
inline bool IMFileLoginRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileLoginRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileLoginRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileLoginRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMFileLoginRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileLoginRsp.result_code)
  return result_code_;
}
inline void IMFileLoginRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileLoginRsp.result_code)
}

// required string task_id = 2;
inline bool IMFileLoginRsp::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileLoginRsp::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileLoginRsp::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileLoginRsp::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_task_id();
}
inline const ::std::string& IMFileLoginRsp::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileLoginRsp.task_id)
  return task_id_.GetNoArena();
}
inline void IMFileLoginRsp::set_task_id(const ::std::string& value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileLoginRsp.task_id)
}
#if LANG_CXX11
inline void IMFileLoginRsp::set_task_id(::std::string&& value) {
  set_has_task_id();
  task_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileLoginRsp.task_id)
}
#endif
inline void IMFileLoginRsp::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileLoginRsp.task_id)
}
inline void IMFileLoginRsp::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileLoginRsp.task_id)
}
inline ::std::string* IMFileLoginRsp::mutable_task_id() {
  set_has_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileLoginRsp.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileLoginRsp::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileLoginRsp.task_id)
  if (!has_task_id()) {
    return NULL;
  }
  clear_has_task_id();
  return task_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileLoginRsp::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileLoginRsp.task_id)
}

// -------------------------------------------------------------------

// IMFileState

// required .IM.BaseDefine.ClientFileState state = 1;
inline bool IMFileState::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileState::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileState::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileState::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::IM::BaseDefine::ClientFileState IMFileState::state() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileState.state)
  return static_cast< ::IM::BaseDefine::ClientFileState >(state_);
}
inline void IMFileState::set_state(::IM::BaseDefine::ClientFileState value) {
  assert(::IM::BaseDefine::ClientFileState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileState.state)
}

// required string task_id = 2;
inline bool IMFileState::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileState::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileState::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileState::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_task_id();
}
inline const ::std::string& IMFileState::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileState.task_id)
  return task_id_.GetNoArena();
}
inline void IMFileState::set_task_id(const ::std::string& value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileState.task_id)
}
#if LANG_CXX11
inline void IMFileState::set_task_id(::std::string&& value) {
  set_has_task_id();
  task_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileState.task_id)
}
#endif
inline void IMFileState::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileState.task_id)
}
inline void IMFileState::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileState.task_id)
}
inline ::std::string* IMFileState::mutable_task_id() {
  set_has_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileState.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileState::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileState.task_id)
  if (!has_task_id()) {
    return NULL;
  }
  clear_has_task_id();
  return task_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileState::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileState.task_id)
}

// required uint32 user_id = 3;
inline bool IMFileState::has_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFileState::set_has_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFileState::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFileState::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMFileState::user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileState.user_id)
  return user_id_;
}
inline void IMFileState::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileState.user_id)
}

// -------------------------------------------------------------------

// IMFilePullDataReq

// required string task_id = 1;
inline bool IMFilePullDataReq::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFilePullDataReq::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFilePullDataReq::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFilePullDataReq::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_task_id();
}
inline const ::std::string& IMFilePullDataReq::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataReq.task_id)
  return task_id_.GetNoArena();
}
inline void IMFilePullDataReq::set_task_id(const ::std::string& value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataReq.task_id)
}
#if LANG_CXX11
inline void IMFilePullDataReq::set_task_id(::std::string&& value) {
  set_has_task_id();
  task_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFilePullDataReq.task_id)
}
#endif
inline void IMFilePullDataReq::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFilePullDataReq.task_id)
}
inline void IMFilePullDataReq::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFilePullDataReq.task_id)
}
inline ::std::string* IMFilePullDataReq::mutable_task_id() {
  set_has_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFilePullDataReq.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFilePullDataReq::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFilePullDataReq.task_id)
  if (!has_task_id()) {
    return NULL;
  }
  clear_has_task_id();
  return task_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFilePullDataReq::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFilePullDataReq.task_id)
}

// required uint32 user_id = 2;
inline bool IMFilePullDataReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFilePullDataReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFilePullDataReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFilePullDataReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMFilePullDataReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataReq.user_id)
  return user_id_;
}
inline void IMFilePullDataReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataReq.user_id)
}

// required .IM.BaseDefine.TransferFileType trans_mode = 3;
inline bool IMFilePullDataReq::has_trans_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMFilePullDataReq::set_has_trans_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMFilePullDataReq::clear_has_trans_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMFilePullDataReq::clear_trans_mode() {
  trans_mode_ = 1;
  clear_has_trans_mode();
}
inline ::IM::BaseDefine::TransferFileType IMFilePullDataReq::trans_mode() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataReq.trans_mode)
  return static_cast< ::IM::BaseDefine::TransferFileType >(trans_mode_);
}
inline void IMFilePullDataReq::set_trans_mode(::IM::BaseDefine::TransferFileType value) {
  assert(::IM::BaseDefine::TransferFileType_IsValid(value));
  set_has_trans_mode();
  trans_mode_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataReq.trans_mode)
}

// required uint32 offset = 4;
inline bool IMFilePullDataReq::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFilePullDataReq::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFilePullDataReq::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFilePullDataReq::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 IMFilePullDataReq::offset() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataReq.offset)
  return offset_;
}
inline void IMFilePullDataReq::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataReq.offset)
}

// required uint32 data_size = 5;
inline bool IMFilePullDataReq::has_data_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMFilePullDataReq::set_has_data_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMFilePullDataReq::clear_has_data_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMFilePullDataReq::clear_data_size() {
  data_size_ = 0u;
  clear_has_data_size();
}
inline ::google::protobuf::uint32 IMFilePullDataReq::data_size() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataReq.data_size)
  return data_size_;
}
inline void IMFilePullDataReq::set_data_size(::google::protobuf::uint32 value) {
  set_has_data_size();
  data_size_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataReq.data_size)
}

// -------------------------------------------------------------------

// IMFilePullDataRsp

// required uint32 result_code = 1;
inline bool IMFilePullDataRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFilePullDataRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFilePullDataRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFilePullDataRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMFilePullDataRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataRsp.result_code)
  return result_code_;
}
inline void IMFilePullDataRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataRsp.result_code)
}

// required string task_id = 2;
inline bool IMFilePullDataRsp::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFilePullDataRsp::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFilePullDataRsp::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFilePullDataRsp::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_task_id();
}
inline const ::std::string& IMFilePullDataRsp::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataRsp.task_id)
  return task_id_.GetNoArena();
}
inline void IMFilePullDataRsp::set_task_id(const ::std::string& value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataRsp.task_id)
}
#if LANG_CXX11
inline void IMFilePullDataRsp::set_task_id(::std::string&& value) {
  set_has_task_id();
  task_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFilePullDataRsp.task_id)
}
#endif
inline void IMFilePullDataRsp::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFilePullDataRsp.task_id)
}
inline void IMFilePullDataRsp::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFilePullDataRsp.task_id)
}
inline ::std::string* IMFilePullDataRsp::mutable_task_id() {
  set_has_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFilePullDataRsp.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFilePullDataRsp::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFilePullDataRsp.task_id)
  if (!has_task_id()) {
    return NULL;
  }
  clear_has_task_id();
  return task_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFilePullDataRsp::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFilePullDataRsp.task_id)
}

// required uint32 user_id = 3;
inline bool IMFilePullDataRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMFilePullDataRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMFilePullDataRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMFilePullDataRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMFilePullDataRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataRsp.user_id)
  return user_id_;
}
inline void IMFilePullDataRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataRsp.user_id)
}

// required uint32 offset = 4;
inline bool IMFilePullDataRsp::has_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMFilePullDataRsp::set_has_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMFilePullDataRsp::clear_has_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMFilePullDataRsp::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 IMFilePullDataRsp::offset() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataRsp.offset)
  return offset_;
}
inline void IMFilePullDataRsp::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataRsp.offset)
}

// required bytes file_data = 5;
inline bool IMFilePullDataRsp::has_file_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFilePullDataRsp::set_has_file_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFilePullDataRsp::clear_has_file_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFilePullDataRsp::clear_file_data() {
  file_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_file_data();
}
inline const ::std::string& IMFilePullDataRsp::file_data() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFilePullDataRsp.file_data)
  return file_data_.GetNoArena();
}
inline void IMFilePullDataRsp::set_file_data(const ::std::string& value) {
  set_has_file_data();
  file_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFilePullDataRsp.file_data)
}
#if LANG_CXX11
inline void IMFilePullDataRsp::set_file_data(::std::string&& value) {
  set_has_file_data();
  file_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFilePullDataRsp.file_data)
}
#endif
inline void IMFilePullDataRsp::set_file_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_file_data();
  file_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFilePullDataRsp.file_data)
}
inline void IMFilePullDataRsp::set_file_data(const void* value, size_t size) {
  set_has_file_data();
  file_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFilePullDataRsp.file_data)
}
inline ::std::string* IMFilePullDataRsp::mutable_file_data() {
  set_has_file_data();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFilePullDataRsp.file_data)
  return file_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFilePullDataRsp::release_file_data() {
  // @@protoc_insertion_point(field_release:IM.File.IMFilePullDataRsp.file_data)
  if (!has_file_data()) {
    return NULL;
  }
  clear_has_file_data();
  return file_data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFilePullDataRsp::set_allocated_file_data(::std::string* file_data) {
  if (file_data != NULL) {
    set_has_file_data();
  } else {
    clear_has_file_data();
  }
  file_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_data);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFilePullDataRsp.file_data)
}

// -------------------------------------------------------------------

// IMFileReq

// required uint32 from_user_id = 1;
inline bool IMFileReq::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileReq::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileReq::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileReq::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
inline ::google::protobuf::uint32 IMFileReq::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileReq.from_user_id)
  return from_user_id_;
}
inline void IMFileReq::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileReq.from_user_id)
}

// required uint32 to_user_id = 2;
inline bool IMFileReq::has_to_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFileReq::set_has_to_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFileReq::clear_has_to_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFileReq::clear_to_user_id() {
  to_user_id_ = 0u;
  clear_has_to_user_id();
}
inline ::google::protobuf::uint32 IMFileReq::to_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileReq.to_user_id)
  return to_user_id_;
}
inline void IMFileReq::set_to_user_id(::google::protobuf::uint32 value) {
  set_has_to_user_id();
  to_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileReq.to_user_id)
}

// required string file_name = 3;
inline bool IMFileReq::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileReq::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileReq::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileReq::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_file_name();
}
inline const ::std::string& IMFileReq::file_name() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileReq.file_name)
  return file_name_.GetNoArena();
}
inline void IMFileReq::set_file_name(const ::std::string& value) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileReq.file_name)
}
#if LANG_CXX11
inline void IMFileReq::set_file_name(::std::string&& value) {
  set_has_file_name();
  file_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileReq.file_name)
}
#endif
inline void IMFileReq::set_file_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileReq.file_name)
}
inline void IMFileReq::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileReq.file_name)
}
inline ::std::string* IMFileReq::mutable_file_name() {
  set_has_file_name();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileReq.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileReq::release_file_name() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileReq.file_name)
  if (!has_file_name()) {
    return NULL;
  }
  clear_has_file_name();
  return file_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileReq::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    set_has_file_name();
  } else {
    clear_has_file_name();
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileReq.file_name)
}

// required uint32 file_size = 4;
inline bool IMFileReq::has_file_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMFileReq::set_has_file_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMFileReq::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMFileReq::clear_file_size() {
  file_size_ = 0u;
  clear_has_file_size();
}
inline ::google::protobuf::uint32 IMFileReq::file_size() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileReq.file_size)
  return file_size_;
}
inline void IMFileReq::set_file_size(::google::protobuf::uint32 value) {
  set_has_file_size();
  file_size_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileReq.file_size)
}

// required .IM.BaseDefine.TransferFileType trans_mode = 5;
inline bool IMFileReq::has_trans_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMFileReq::set_has_trans_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMFileReq::clear_has_trans_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMFileReq::clear_trans_mode() {
  trans_mode_ = 1;
  clear_has_trans_mode();
}
inline ::IM::BaseDefine::TransferFileType IMFileReq::trans_mode() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileReq.trans_mode)
  return static_cast< ::IM::BaseDefine::TransferFileType >(trans_mode_);
}
inline void IMFileReq::set_trans_mode(::IM::BaseDefine::TransferFileType value) {
  assert(::IM::BaseDefine::TransferFileType_IsValid(value));
  set_has_trans_mode();
  trans_mode_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileReq.trans_mode)
}

// -------------------------------------------------------------------

// IMFileRsp

// required uint32 result_code = 1;
inline bool IMFileRsp::has_result_code() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFileRsp::set_has_result_code() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFileRsp::clear_has_result_code() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFileRsp::clear_result_code() {
  result_code_ = 0u;
  clear_has_result_code();
}
inline ::google::protobuf::uint32 IMFileRsp::result_code() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.result_code)
  return result_code_;
}
inline void IMFileRsp::set_result_code(::google::protobuf::uint32 value) {
  set_has_result_code();
  result_code_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileRsp.result_code)
}

// required uint32 from_user_id = 2;
inline bool IMFileRsp::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMFileRsp::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMFileRsp::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMFileRsp::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
inline ::google::protobuf::uint32 IMFileRsp::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.from_user_id)
  return from_user_id_;
}
inline void IMFileRsp::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileRsp.from_user_id)
}

// required uint32 to_user_id = 3;
inline bool IMFileRsp::has_to_user_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMFileRsp::set_has_to_user_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMFileRsp::clear_has_to_user_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMFileRsp::clear_to_user_id() {
  to_user_id_ = 0u;
  clear_has_to_user_id();
}
inline ::google::protobuf::uint32 IMFileRsp::to_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.to_user_id)
  return to_user_id_;
}
inline void IMFileRsp::set_to_user_id(::google::protobuf::uint32 value) {
  set_has_to_user_id();
  to_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileRsp.to_user_id)
}

// required string file_name = 4;
inline bool IMFileRsp::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileRsp::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileRsp::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileRsp::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_file_name();
}
inline const ::std::string& IMFileRsp::file_name() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.file_name)
  return file_name_.GetNoArena();
}
inline void IMFileRsp::set_file_name(const ::std::string& value) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileRsp.file_name)
}
#if LANG_CXX11
inline void IMFileRsp::set_file_name(::std::string&& value) {
  set_has_file_name();
  file_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileRsp.file_name)
}
#endif
inline void IMFileRsp::set_file_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileRsp.file_name)
}
inline void IMFileRsp::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileRsp.file_name)
}
inline ::std::string* IMFileRsp::mutable_file_name() {
  set_has_file_name();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileRsp.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileRsp::release_file_name() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileRsp.file_name)
  if (!has_file_name()) {
    return NULL;
  }
  clear_has_file_name();
  return file_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileRsp::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    set_has_file_name();
  } else {
    clear_has_file_name();
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileRsp.file_name)
}

// required string task_id = 5;
inline bool IMFileRsp::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileRsp::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileRsp::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileRsp::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_task_id();
}
inline const ::std::string& IMFileRsp::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.task_id)
  return task_id_.GetNoArena();
}
inline void IMFileRsp::set_task_id(const ::std::string& value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileRsp.task_id)
}
#if LANG_CXX11
inline void IMFileRsp::set_task_id(::std::string&& value) {
  set_has_task_id();
  task_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileRsp.task_id)
}
#endif
inline void IMFileRsp::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileRsp.task_id)
}
inline void IMFileRsp::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileRsp.task_id)
}
inline ::std::string* IMFileRsp::mutable_task_id() {
  set_has_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileRsp.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileRsp::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileRsp.task_id)
  if (!has_task_id()) {
    return NULL;
  }
  clear_has_task_id();
  return task_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileRsp::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileRsp.task_id)
}

// repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
inline int IMFileRsp::ip_addr_list_size() const {
  return ip_addr_list_.size();
}
inline ::IM::BaseDefine::IpAddr* IMFileRsp::mutable_ip_addr_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileRsp.ip_addr_list)
  return ip_addr_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
IMFileRsp::mutable_ip_addr_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.File.IMFileRsp.ip_addr_list)
  return &ip_addr_list_;
}
inline const ::IM::BaseDefine::IpAddr& IMFileRsp::ip_addr_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.ip_addr_list)
  return ip_addr_list_.Get(index);
}
inline ::IM::BaseDefine::IpAddr* IMFileRsp::add_ip_addr_list() {
  // @@protoc_insertion_point(field_add:IM.File.IMFileRsp.ip_addr_list)
  return ip_addr_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
IMFileRsp::ip_addr_list() const {
  // @@protoc_insertion_point(field_list:IM.File.IMFileRsp.ip_addr_list)
  return ip_addr_list_;
}

// required .IM.BaseDefine.TransferFileType trans_mode = 7;
inline bool IMFileRsp::has_trans_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMFileRsp::set_has_trans_mode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMFileRsp::clear_has_trans_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMFileRsp::clear_trans_mode() {
  trans_mode_ = 1;
  clear_has_trans_mode();
}
inline ::IM::BaseDefine::TransferFileType IMFileRsp::trans_mode() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileRsp.trans_mode)
  return static_cast< ::IM::BaseDefine::TransferFileType >(trans_mode_);
}
inline void IMFileRsp::set_trans_mode(::IM::BaseDefine::TransferFileType value) {
  assert(::IM::BaseDefine::TransferFileType_IsValid(value));
  set_has_trans_mode();
  trans_mode_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileRsp.trans_mode)
}

// -------------------------------------------------------------------

// IMFileNotify

// required uint32 from_user_id = 1;
inline bool IMFileNotify::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFileNotify::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFileNotify::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFileNotify::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
inline ::google::protobuf::uint32 IMFileNotify::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.from_user_id)
  return from_user_id_;
}
inline void IMFileNotify::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.from_user_id)
}

// required uint32 to_user_id = 2;
inline bool IMFileNotify::has_to_user_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMFileNotify::set_has_to_user_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMFileNotify::clear_has_to_user_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMFileNotify::clear_to_user_id() {
  to_user_id_ = 0u;
  clear_has_to_user_id();
}
inline ::google::protobuf::uint32 IMFileNotify::to_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.to_user_id)
  return to_user_id_;
}
inline void IMFileNotify::set_to_user_id(::google::protobuf::uint32 value) {
  set_has_to_user_id();
  to_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.to_user_id)
}

// required string file_name = 3;
inline bool IMFileNotify::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileNotify::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileNotify::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileNotify::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_file_name();
}
inline const ::std::string& IMFileNotify::file_name() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.file_name)
  return file_name_.GetNoArena();
}
inline void IMFileNotify::set_file_name(const ::std::string& value) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.file_name)
}
#if LANG_CXX11
inline void IMFileNotify::set_file_name(::std::string&& value) {
  set_has_file_name();
  file_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileNotify.file_name)
}
#endif
inline void IMFileNotify::set_file_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileNotify.file_name)
}
inline void IMFileNotify::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileNotify.file_name)
}
inline ::std::string* IMFileNotify::mutable_file_name() {
  set_has_file_name();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileNotify.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileNotify::release_file_name() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileNotify.file_name)
  if (!has_file_name()) {
    return NULL;
  }
  clear_has_file_name();
  return file_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileNotify::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    set_has_file_name();
  } else {
    clear_has_file_name();
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileNotify.file_name)
}

// required uint32 file_size = 4;
inline bool IMFileNotify::has_file_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMFileNotify::set_has_file_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMFileNotify::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMFileNotify::clear_file_size() {
  file_size_ = 0u;
  clear_has_file_size();
}
inline ::google::protobuf::uint32 IMFileNotify::file_size() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.file_size)
  return file_size_;
}
inline void IMFileNotify::set_file_size(::google::protobuf::uint32 value) {
  set_has_file_size();
  file_size_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.file_size)
}

// required string task_id = 5;
inline bool IMFileNotify::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileNotify::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileNotify::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileNotify::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_task_id();
}
inline const ::std::string& IMFileNotify::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.task_id)
  return task_id_.GetNoArena();
}
inline void IMFileNotify::set_task_id(const ::std::string& value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.task_id)
}
#if LANG_CXX11
inline void IMFileNotify::set_task_id(::std::string&& value) {
  set_has_task_id();
  task_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileNotify.task_id)
}
#endif
inline void IMFileNotify::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileNotify.task_id)
}
inline void IMFileNotify::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileNotify.task_id)
}
inline ::std::string* IMFileNotify::mutable_task_id() {
  set_has_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileNotify.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileNotify::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileNotify.task_id)
  if (!has_task_id()) {
    return NULL;
  }
  clear_has_task_id();
  return task_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileNotify::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileNotify.task_id)
}

// repeated .IM.BaseDefine.IpAddr ip_addr_list = 6;
inline int IMFileNotify::ip_addr_list_size() const {
  return ip_addr_list_.size();
}
inline ::IM::BaseDefine::IpAddr* IMFileNotify::mutable_ip_addr_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileNotify.ip_addr_list)
  return ip_addr_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
IMFileNotify::mutable_ip_addr_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.File.IMFileNotify.ip_addr_list)
  return &ip_addr_list_;
}
inline const ::IM::BaseDefine::IpAddr& IMFileNotify::ip_addr_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.ip_addr_list)
  return ip_addr_list_.Get(index);
}
inline ::IM::BaseDefine::IpAddr* IMFileNotify::add_ip_addr_list() {
  // @@protoc_insertion_point(field_add:IM.File.IMFileNotify.ip_addr_list)
  return ip_addr_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
IMFileNotify::ip_addr_list() const {
  // @@protoc_insertion_point(field_list:IM.File.IMFileNotify.ip_addr_list)
  return ip_addr_list_;
}

// required .IM.BaseDefine.TransferFileType trans_mode = 7;
inline bool IMFileNotify::has_trans_mode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IMFileNotify::set_has_trans_mode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IMFileNotify::clear_has_trans_mode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IMFileNotify::clear_trans_mode() {
  trans_mode_ = 1;
  clear_has_trans_mode();
}
inline ::IM::BaseDefine::TransferFileType IMFileNotify::trans_mode() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.trans_mode)
  return static_cast< ::IM::BaseDefine::TransferFileType >(trans_mode_);
}
inline void IMFileNotify::set_trans_mode(::IM::BaseDefine::TransferFileType value) {
  assert(::IM::BaseDefine::TransferFileType_IsValid(value));
  set_has_trans_mode();
  trans_mode_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.trans_mode)
}

// required uint32 offline_ready = 8;
inline bool IMFileNotify::has_offline_ready() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMFileNotify::set_has_offline_ready() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMFileNotify::clear_has_offline_ready() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMFileNotify::clear_offline_ready() {
  offline_ready_ = 0u;
  clear_has_offline_ready();
}
inline ::google::protobuf::uint32 IMFileNotify::offline_ready() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileNotify.offline_ready)
  return offline_ready_;
}
inline void IMFileNotify::set_offline_ready(::google::protobuf::uint32 value) {
  set_has_offline_ready();
  offline_ready_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileNotify.offline_ready)
}

// -------------------------------------------------------------------

// IMFileHasOfflineReq

// required uint32 user_id = 1;
inline bool IMFileHasOfflineReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileHasOfflineReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileHasOfflineReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileHasOfflineReq::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMFileHasOfflineReq::user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileHasOfflineReq.user_id)
  return user_id_;
}
inline void IMFileHasOfflineReq::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileHasOfflineReq.user_id)
}

// optional bytes attach_data = 20;
inline bool IMFileHasOfflineReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileHasOfflineReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileHasOfflineReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileHasOfflineReq::clear_attach_data() {
  attach_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_attach_data();
}
inline const ::std::string& IMFileHasOfflineReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileHasOfflineReq.attach_data)
  return attach_data_.GetNoArena();
}
inline void IMFileHasOfflineReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileHasOfflineReq.attach_data)
}
#if LANG_CXX11
inline void IMFileHasOfflineReq::set_attach_data(::std::string&& value) {
  set_has_attach_data();
  attach_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileHasOfflineReq.attach_data)
}
#endif
inline void IMFileHasOfflineReq::set_attach_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileHasOfflineReq.attach_data)
}
inline void IMFileHasOfflineReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileHasOfflineReq.attach_data)
}
inline ::std::string* IMFileHasOfflineReq::mutable_attach_data() {
  set_has_attach_data();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileHasOfflineReq.attach_data)
  return attach_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileHasOfflineReq::release_attach_data() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileHasOfflineReq.attach_data)
  if (!has_attach_data()) {
    return NULL;
  }
  clear_has_attach_data();
  return attach_data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileHasOfflineReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data != NULL) {
    set_has_attach_data();
  } else {
    clear_has_attach_data();
  }
  attach_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), attach_data);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileHasOfflineReq.attach_data)
}

// -------------------------------------------------------------------

// IMFileHasOfflineRsp

// required uint32 user_id = 1;
inline bool IMFileHasOfflineRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileHasOfflineRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileHasOfflineRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileHasOfflineRsp::clear_user_id() {
  user_id_ = 0u;
  clear_has_user_id();
}
inline ::google::protobuf::uint32 IMFileHasOfflineRsp::user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileHasOfflineRsp.user_id)
  return user_id_;
}
inline void IMFileHasOfflineRsp::set_user_id(::google::protobuf::uint32 value) {
  set_has_user_id();
  user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileHasOfflineRsp.user_id)
}

// repeated .IM.BaseDefine.OfflineFileInfo offline_file_list = 2;
inline int IMFileHasOfflineRsp::offline_file_list_size() const {
  return offline_file_list_.size();
}
inline ::IM::BaseDefine::OfflineFileInfo* IMFileHasOfflineRsp::mutable_offline_file_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileHasOfflineRsp.offline_file_list)
  return offline_file_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo >*
IMFileHasOfflineRsp::mutable_offline_file_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.File.IMFileHasOfflineRsp.offline_file_list)
  return &offline_file_list_;
}
inline const ::IM::BaseDefine::OfflineFileInfo& IMFileHasOfflineRsp::offline_file_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileHasOfflineRsp.offline_file_list)
  return offline_file_list_.Get(index);
}
inline ::IM::BaseDefine::OfflineFileInfo* IMFileHasOfflineRsp::add_offline_file_list() {
  // @@protoc_insertion_point(field_add:IM.File.IMFileHasOfflineRsp.offline_file_list)
  return offline_file_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::OfflineFileInfo >&
IMFileHasOfflineRsp::offline_file_list() const {
  // @@protoc_insertion_point(field_list:IM.File.IMFileHasOfflineRsp.offline_file_list)
  return offline_file_list_;
}

// repeated .IM.BaseDefine.IpAddr ip_addr_list = 3;
inline int IMFileHasOfflineRsp::ip_addr_list_size() const {
  return ip_addr_list_.size();
}
inline ::IM::BaseDefine::IpAddr* IMFileHasOfflineRsp::mutable_ip_addr_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileHasOfflineRsp.ip_addr_list)
  return ip_addr_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >*
IMFileHasOfflineRsp::mutable_ip_addr_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.File.IMFileHasOfflineRsp.ip_addr_list)
  return &ip_addr_list_;
}
inline const ::IM::BaseDefine::IpAddr& IMFileHasOfflineRsp::ip_addr_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileHasOfflineRsp.ip_addr_list)
  return ip_addr_list_.Get(index);
}
inline ::IM::BaseDefine::IpAddr* IMFileHasOfflineRsp::add_ip_addr_list() {
  // @@protoc_insertion_point(field_add:IM.File.IMFileHasOfflineRsp.ip_addr_list)
  return ip_addr_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::IpAddr >&
IMFileHasOfflineRsp::ip_addr_list() const {
  // @@protoc_insertion_point(field_list:IM.File.IMFileHasOfflineRsp.ip_addr_list)
  return ip_addr_list_;
}

// optional bytes attach_data = 20;
inline bool IMFileHasOfflineRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileHasOfflineRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileHasOfflineRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileHasOfflineRsp::clear_attach_data() {
  attach_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_attach_data();
}
inline const ::std::string& IMFileHasOfflineRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileHasOfflineRsp.attach_data)
  return attach_data_.GetNoArena();
}
inline void IMFileHasOfflineRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileHasOfflineRsp.attach_data)
}
#if LANG_CXX11
inline void IMFileHasOfflineRsp::set_attach_data(::std::string&& value) {
  set_has_attach_data();
  attach_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileHasOfflineRsp.attach_data)
}
#endif
inline void IMFileHasOfflineRsp::set_attach_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileHasOfflineRsp.attach_data)
}
inline void IMFileHasOfflineRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  attach_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileHasOfflineRsp.attach_data)
}
inline ::std::string* IMFileHasOfflineRsp::mutable_attach_data() {
  set_has_attach_data();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileHasOfflineRsp.attach_data)
  return attach_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileHasOfflineRsp::release_attach_data() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileHasOfflineRsp.attach_data)
  if (!has_attach_data()) {
    return NULL;
  }
  clear_has_attach_data();
  return attach_data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileHasOfflineRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data != NULL) {
    set_has_attach_data();
  } else {
    clear_has_attach_data();
  }
  attach_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), attach_data);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileHasOfflineRsp.attach_data)
}

// -------------------------------------------------------------------

// IMFileAddOfflineReq

// required uint32 from_user_id = 1;
inline bool IMFileAddOfflineReq::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFileAddOfflineReq::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFileAddOfflineReq::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFileAddOfflineReq::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
inline ::google::protobuf::uint32 IMFileAddOfflineReq::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileAddOfflineReq.from_user_id)
  return from_user_id_;
}
inline void IMFileAddOfflineReq::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileAddOfflineReq.from_user_id)
}

// required uint32 to_user_id = 2;
inline bool IMFileAddOfflineReq::has_to_user_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMFileAddOfflineReq::set_has_to_user_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMFileAddOfflineReq::clear_has_to_user_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMFileAddOfflineReq::clear_to_user_id() {
  to_user_id_ = 0u;
  clear_has_to_user_id();
}
inline ::google::protobuf::uint32 IMFileAddOfflineReq::to_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileAddOfflineReq.to_user_id)
  return to_user_id_;
}
inline void IMFileAddOfflineReq::set_to_user_id(::google::protobuf::uint32 value) {
  set_has_to_user_id();
  to_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileAddOfflineReq.to_user_id)
}

// required string task_id = 3;
inline bool IMFileAddOfflineReq::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileAddOfflineReq::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileAddOfflineReq::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileAddOfflineReq::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_task_id();
}
inline const ::std::string& IMFileAddOfflineReq::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileAddOfflineReq.task_id)
  return task_id_.GetNoArena();
}
inline void IMFileAddOfflineReq::set_task_id(const ::std::string& value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileAddOfflineReq.task_id)
}
#if LANG_CXX11
inline void IMFileAddOfflineReq::set_task_id(::std::string&& value) {
  set_has_task_id();
  task_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileAddOfflineReq.task_id)
}
#endif
inline void IMFileAddOfflineReq::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileAddOfflineReq.task_id)
}
inline void IMFileAddOfflineReq::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileAddOfflineReq.task_id)
}
inline ::std::string* IMFileAddOfflineReq::mutable_task_id() {
  set_has_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileAddOfflineReq.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileAddOfflineReq::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileAddOfflineReq.task_id)
  if (!has_task_id()) {
    return NULL;
  }
  clear_has_task_id();
  return task_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileAddOfflineReq::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileAddOfflineReq.task_id)
}

// required string file_name = 4;
inline bool IMFileAddOfflineReq::has_file_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileAddOfflineReq::set_has_file_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileAddOfflineReq::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileAddOfflineReq::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_file_name();
}
inline const ::std::string& IMFileAddOfflineReq::file_name() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileAddOfflineReq.file_name)
  return file_name_.GetNoArena();
}
inline void IMFileAddOfflineReq::set_file_name(const ::std::string& value) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileAddOfflineReq.file_name)
}
#if LANG_CXX11
inline void IMFileAddOfflineReq::set_file_name(::std::string&& value) {
  set_has_file_name();
  file_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileAddOfflineReq.file_name)
}
#endif
inline void IMFileAddOfflineReq::set_file_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileAddOfflineReq.file_name)
}
inline void IMFileAddOfflineReq::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileAddOfflineReq.file_name)
}
inline ::std::string* IMFileAddOfflineReq::mutable_file_name() {
  set_has_file_name();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileAddOfflineReq.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileAddOfflineReq::release_file_name() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileAddOfflineReq.file_name)
  if (!has_file_name()) {
    return NULL;
  }
  clear_has_file_name();
  return file_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileAddOfflineReq::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    set_has_file_name();
  } else {
    clear_has_file_name();
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileAddOfflineReq.file_name)
}

// required uint32 file_size = 5;
inline bool IMFileAddOfflineReq::has_file_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMFileAddOfflineReq::set_has_file_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMFileAddOfflineReq::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMFileAddOfflineReq::clear_file_size() {
  file_size_ = 0u;
  clear_has_file_size();
}
inline ::google::protobuf::uint32 IMFileAddOfflineReq::file_size() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileAddOfflineReq.file_size)
  return file_size_;
}
inline void IMFileAddOfflineReq::set_file_size(::google::protobuf::uint32 value) {
  set_has_file_size();
  file_size_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileAddOfflineReq.file_size)
}

// -------------------------------------------------------------------

// IMFileDelOfflineReq

// required uint32 from_user_id = 1;
inline bool IMFileDelOfflineReq::has_from_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMFileDelOfflineReq::set_has_from_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMFileDelOfflineReq::clear_has_from_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMFileDelOfflineReq::clear_from_user_id() {
  from_user_id_ = 0u;
  clear_has_from_user_id();
}
inline ::google::protobuf::uint32 IMFileDelOfflineReq::from_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileDelOfflineReq.from_user_id)
  return from_user_id_;
}
inline void IMFileDelOfflineReq::set_from_user_id(::google::protobuf::uint32 value) {
  set_has_from_user_id();
  from_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileDelOfflineReq.from_user_id)
}

// required uint32 to_user_id = 2;
inline bool IMFileDelOfflineReq::has_to_user_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMFileDelOfflineReq::set_has_to_user_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMFileDelOfflineReq::clear_has_to_user_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMFileDelOfflineReq::clear_to_user_id() {
  to_user_id_ = 0u;
  clear_has_to_user_id();
}
inline ::google::protobuf::uint32 IMFileDelOfflineReq::to_user_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileDelOfflineReq.to_user_id)
  return to_user_id_;
}
inline void IMFileDelOfflineReq::set_to_user_id(::google::protobuf::uint32 value) {
  set_has_to_user_id();
  to_user_id_ = value;
  // @@protoc_insertion_point(field_set:IM.File.IMFileDelOfflineReq.to_user_id)
}

// required string task_id = 3;
inline bool IMFileDelOfflineReq::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMFileDelOfflineReq::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMFileDelOfflineReq::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMFileDelOfflineReq::clear_task_id() {
  task_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_task_id();
}
inline const ::std::string& IMFileDelOfflineReq::task_id() const {
  // @@protoc_insertion_point(field_get:IM.File.IMFileDelOfflineReq.task_id)
  return task_id_.GetNoArena();
}
inline void IMFileDelOfflineReq::set_task_id(const ::std::string& value) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IM.File.IMFileDelOfflineReq.task_id)
}
#if LANG_CXX11
inline void IMFileDelOfflineReq::set_task_id(::std::string&& value) {
  set_has_task_id();
  task_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IM.File.IMFileDelOfflineReq.task_id)
}
#endif
inline void IMFileDelOfflineReq::set_task_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IM.File.IMFileDelOfflineReq.task_id)
}
inline void IMFileDelOfflineReq::set_task_id(const char* value, size_t size) {
  set_has_task_id();
  task_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IM.File.IMFileDelOfflineReq.task_id)
}
inline ::std::string* IMFileDelOfflineReq::mutable_task_id() {
  set_has_task_id();
  // @@protoc_insertion_point(field_mutable:IM.File.IMFileDelOfflineReq.task_id)
  return task_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IMFileDelOfflineReq::release_task_id() {
  // @@protoc_insertion_point(field_release:IM.File.IMFileDelOfflineReq.task_id)
  if (!has_task_id()) {
    return NULL;
  }
  clear_has_task_id();
  return task_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IMFileDelOfflineReq::set_allocated_task_id(::std::string* task_id) {
  if (task_id != NULL) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  task_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), task_id);
  // @@protoc_insertion_point(field_set_allocated:IM.File.IMFileDelOfflineReq.task_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace File
}  // namespace IM

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_IM_2eFile_2eproto
